<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iOS @ Taipei</title>
  
  <subtitle>iOS and his good friends</subtitle>
  <link href="https://ios.taipei/atom.xml" rel="self"/>
  
  <link href="https://ios.taipei/"/>
  <updated>2022-10-14T06:17:28.669Z</updated>
  <id>https://ios.taipei/</id>
  
  <author>
    <name>Aki Yu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift 語言的基礎 - Range 範圍表示式</title>
    <link href="https://ios.taipei/2022/10/14/01-11-swift/"/>
    <id>https://ios.taipei/2022/10/14/01-11-swift/</id>
    <published>2022-10-13T16:00:05.000Z</published>
    <updated>2022-10-14T06:17:28.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Range-範圍"><a href="#Range-範圍" class="headerlink" title="Range 範圍"></a>Range 範圍</h1><h2 id="封閉式-Closed-Range"><a href="#封閉式-Closed-Range" class="headerlink" title="封閉式 Closed Range"></a>封閉式 Closed Range</h2><pre><code class="swift">for number in 1...5 {  print(number)}</code></pre><p>range 只有正向的寫法，沒有逆向顛倒的寫法</p><p>以下寫法是有問題的</p><pre><code class="swift">for number in 5...1 {  print(number)}</code></pre><h2 id="半開放-Half-Open-Range"><a href="#半開放-Half-Open-Range" class="headerlink" title="半開放 Half-Open Range"></a>半開放 Half-Open Range</h2><pre><code class="swift">for number in 1..&lt;4 {  print(number)}</code></pre><h2 id="單邊-One-Sided-Range"><a href="#單邊-One-Sided-Range" class="headerlink" title="單邊 One-Sided Range"></a>單邊 One-Sided Range</h2><pre><code class="swift">let range = ..5print(range.contains(-1))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Range-範圍&quot;&gt;&lt;a href=&quot;#Range-範圍&quot; class=&quot;headerlink&quot; title=&quot;Range 範圍&quot;&gt;&lt;/a&gt;Range 範圍&lt;/h1&gt;&lt;h2 id=&quot;封閉式-Closed-Range&quot;&gt;&lt;a href=&quot;#封閉式-Closed-Ra</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 列舉 Enum</title>
    <link href="https://ios.taipei/2022/10/12/01-12-swift/"/>
    <id>https://ios.taipei/2022/10/12/01-12-swift/</id>
    <published>2022-10-11T16:00:05.000Z</published>
    <updated>2022-10-21T01:19:43.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="未完待續"><a href="#未完待續" class="headerlink" title="未完待續"></a>未完待續</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;未完待續&quot;&gt;&lt;a href=&quot;#未完待續&quot; class=&quot;headerlink&quot; title=&quot;未完待續&quot;&gt;&lt;/a&gt;未完待續&lt;/h1&gt;</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - Reference Type / Value Type</title>
    <link href="https://ios.taipei/2022/10/08/01-10-swift/"/>
    <id>https://ios.taipei/2022/10/08/01-10-swift/</id>
    <published>2022-10-07T16:00:05.000Z</published>
    <updated>2022-10-12T05:40:53.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reference-Type-x2F-Value-Type"><a href="#Reference-Type-x2F-Value-Type" class="headerlink" title="Reference Type / Value Type"></a>Reference Type / Value Type</h1><p>所有的程式言語</p><h2 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h2><h2 id="Value-Type"><a href="#Value-Type" class="headerlink" title="Value Type"></a>Value Type</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Reference-Type-x2F-Value-Type&quot;&gt;&lt;a href=&quot;#Reference-Type-x2F-Value-Type&quot; class=&quot;headerlink&quot; title=&quot;Reference Type / Value Type&quot;&gt;&lt;/a&gt;R</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 物件導向(Object Oriented Programming, OOP)</title>
    <link href="https://ios.taipei/2022/10/07/01-09-swift/"/>
    <id>https://ios.taipei/2022/10/07/01-09-swift/</id>
    <published>2022-10-06T16:00:05.000Z</published>
    <updated>2022-10-14T06:21:13.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物件導向-介紹"><a href="#物件導向-介紹" class="headerlink" title="物件導向 - 介紹"></a>物件導向 - 介紹</h1><p>在沒有開始使用物件的觀念時，如何用程式撰寫，來寫出對於一輛汽車的描述？</p><p>範例：</p><p>藍色的東西，有四個輪子，品牌是BMW，還能夠按喇叭。</p><pre><code class="swift">// 車子的顏色let carColor =  .blue// 汽車有 4 個輪胎let numberOfCarTires =  4// 品牌let carBrand = "BMW"// 按喇叭func horn(){  print("Ba Ba Ba")}horn() //按一下喇叭</code></pre><p>如果改用<span style="color:blue">物件</span>的方式來描述呢？</p><p>我們先將一輛車子的設計藍圖先規劃出來，將屬性和操作的可能性，聚合起來，並且將可能改變的數值，變成變數，將其放到設計藍圖的外部。等到有需要建造汽車時，再將變數放進去。</p><p>設計藍圖的觀念  就是程式人說的 <span style="color:blue">類別 (Class)</span></p><h2 id="類別-Class"><a href="#類別-Class" class="headerlink" title="類別(Class)"></a>類別(Class)</h2><pre><code class="swift">class Car {  enum Brand {    case BMW, Benz, Toyata  }  // 顏色  let color = .blue  // 幾條腿  let numberOfTires = 4    // 品牌名  let brand: Brand    init(brand: Brand) { self.brand = brand }    func horn(){ print("Ba Ba Ba") }  }</code></pre><p>其中，有一些名詞，慢慢地要開始熟悉，其中 color(顏色) 變數用以描述車子，我們將之稱之為 <span style="color:blue">屬性 (Property)</span>，按喇叭是一個操作函數，我們將之稱之為 <span style="color:blue">方法 (Method)</span>。</p><p>在使用上，如何用程式描述相同的汽車？</p><pre><code class="swift">// 有一台藍色，有四個輪子，品牌是BMW，還能夠按喇叭。let car1 = Car(brand: .BMW)// 有一台藍色，有四個輪子，品牌是Bens，還能夠按喇叭。let car2 = Car(brand: .Benz)// 有一台藍色，有四個輪子，品牌是Toyota，還能夠按喇叭。let car3 = Car(brand: .Toyata)</code></pre><p>是不是簡潔許多，又可重複地使用設計藍圖一直打造汽車了呢？  這就是物件導向的優點。</p><h2 id="物件-Object"><a href="#物件-Object" class="headerlink" title="物件(Object)"></a>物件(Object)</h2><p>那物件呢？ 其實就是透過Class被製造(init)出來的實體 car1,car2,car3,就是一個個物件了</p><p>我們可以讓 car2 按一下喇叭</p><pre><code class="swift">car2.horn()</code></pre><h2 id="隱藏在-Class-裡的進階觀念"><a href="#隱藏在-Class-裡的進階觀念" class="headerlink" title="隱藏在 Class 裡的進階觀念"></a>隱藏在 Class 裡的進階觀念</h2><p>Class 屬於 Reference Type 的型別, 那什麼是 <span style="color:blue">Reference Type </span>呢？</p><p>留待下一章 <a href="/2022/10/08/01-10-swift/">Reference Type / Value Type</a> 時再解釋。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物件導向-介紹&quot;&gt;&lt;a href=&quot;#物件導向-介紹&quot; class=&quot;headerlink&quot; title=&quot;物件導向 - 介紹&quot;&gt;&lt;/a&gt;物件導向 - 介紹&lt;/h1&gt;&lt;p&gt;在沒有開始使用物件的觀念時，如何用程式撰寫，來寫出對於一輛汽車的描述？&lt;/p&gt;
&lt;p&gt;範例：</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 函數 (Function)</title>
    <link href="https://ios.taipei/2022/10/06/01-07-swift/"/>
    <id>https://ios.taipei/2022/10/06/01-07-swift/</id>
    <published>2022-10-05T16:00:05.000Z</published>
    <updated>2022-10-17T02:05:17.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本函數-介紹"><a href="#基本函數-介紹" class="headerlink" title="基本函數 - 介紹"></a>基本函數 - 介紹</h1><p>函數是一個，用以執行特殊目的一個程式區塊這是一個swift的基礎函數說明</p><pre><code class="swift">func functionName(parameters)-&gt; returnType {  // function body }</code></pre><p>舉例來說，有一個做香腸的函數，我們只要把豬肉放進去，裡面怎麼做，因為被函數包起來了，實作細節要進到函數裡詳查，但函數產出的結果，會得到香腸。</p>  <img src="/images/pig.png" width="280"><pre><code class="swift">func 香腸產生器(放入的肉:豬肉型別)-&gt; 香腸型別 {  // function body     return 1 根香腸}</code></pre><p>當然，一個簡單的函數也可沒有input 也沒有output </p><pre><code class="swift">func greeting() {    print("Hello World!")}</code></pre><p>如果函數完成了之後，要怎麼樣使用呢？只要在程式的生命週期裡，適當的地方呼叫</p><pre><code class="swift">greeting()//或者是var return = 香腸產生器(5隻豬)print(return) // 100 根香腸</code></pre><h2 id="使用系統內建的函數"><a href="#使用系統內建的函數" class="headerlink" title="使用系統內建的函數"></a>使用系統內建的函數</h2><p>其實，print() 就是一個系統內建的函數</p><pre><code class="swift">print("ABC")</code></pre><p>再舉多一個取極大值的例子</p><pre><code class="swift">import Foundationvar value = max(3, 5)print(value) //5</code></pre><p>在使用系統內建的函數，或是使用別的做好的函數庫，在使用之前，都會有個 import 函數庫的操作。如此，能夠使用已經有的函數庫，就不用自己一再地重覆造輪子了</p><p>沒有輪子？自己造一個吧！！！</p><h2 id="第一個使用者自行定義的函數"><a href="#第一個使用者自行定義的函數" class="headerlink" title="第一個使用者自行定義的函數"></a>第一個使用者自行定義的函數</h2><p>用函數來實作一個加法器</p><h3 id="加法器函數範例"><a href="#加法器函數範例" class="headerlink" title="加法器函數範例"></a>加法器函數範例</h3><pre><code class="swift">func addNumbers(num1: Int, num2: Int) -&gt; Int{  return num1 + num2}</code></pre><p>有一個函數，名字叫做「addNumbers」,有兩個輸入參數，分別為 num1 與 num2，型別為 Int, 回傳值 是一個 Int, 能夠回傳 兩個數相加的值。 </p><p><span style="color:red">讀懂程式，是在學習寫程式之前很重要的一個步驟</span></p><p>呼叫函數</p><pre><code class="swift">var result = addNumbers(num1: 3, num2: 4)print(result). //7</code></pre><p>其中 num1 與 num2 是具名參數，如果想要少打一點字，可以使用不具名參數</p><pre><code class="swift">func addNumbers(_ num1: Int, num2: Int) -&gt; Int{  return num1 + num2}</code></pre><p>num1 前多了個 “_”</p><p>呼叫函數,就要配合改為</p><pre><code class="swift">var result = addNumbers(5, num2: 6)print(result). //11</code></pre><p>想要為參數加一個別名，也可以寫成醬子</p><pre><code class="swift">func sum(of num1: Int,and num2: Int) -&gt; Int{  return num1 + num2}</code></pre><p>num1 前多了個 “of”, num2 前多了個 “and”</p><p>呼叫函數,就要配合改為</p><pre><code class="swift">var result = sum(of :5, and : 6)print(result). //11</code></pre><p>是不是比較容易讀了呢？</p><h1 id="函數的多種變化"><a href="#函數的多種變化" class="headerlink" title="函數的多種變化"></a>函數的多種變化</h1><h2 id="不定量參數的函數-Function-with-variadic-parameters"><a href="#不定量參數的函數-Function-with-variadic-parameters" class="headerlink" title="不定量參數的函數 (Function with variadic parameters)"></a>不定量參數的函數 (Function with variadic parameters)</h2><p>有時候想要傳很多參數但參數又不是固定幾個的時候，swift 語言提供了一種未限定參數個數的函數，範例如下：</p><pre><code class="swift">func sum(numbers: Int...) -&gt; Int{    var result = 0  for num in numbers {    result += num  }  return result}</code></pre><p>型別的後面多了 <b>…</b> , 代表著，傳入的參數 numbers, 其實是一個型別為 Int 的 collection，可以讓你傳入 0～很多個參數到函數裡面，而在函數中取值的話，用迴圈把參數裡的值一一取出利用。</p><p>呼叫函數的方法為</p><pre><code class="swift">var rtn = sum(numbers:1,2,3,4,5)print(rtn)</code></pre><h2 id="回傳多個值的函數-Function-with-return-multiple-values"><a href="#回傳多個值的函數-Function-with-return-multiple-values" class="headerlink" title="回傳多個值的函數 (Function with return multiple values)"></a>回傳多個值的函數 (Function with return multiple values)</h2><p>有時候想要回傳很多值的時候，可以回傳一個 Tuple，範例如下：</p><pre><code class="swift">func sum(numbers: Int...) -&gt; (String, Int) {    var result = 0  for num in numbers {    result += num  }  return ("經過計算後的結果", result)}</code></pre><h2 id="巢狀函數-Neste木Function"><a href="#巢狀函數-Neste木Function" class="headerlink" title="巢狀函數 (Neste木Function)"></a>巢狀函數 (Neste木Function)</h2><p>函數裡面也可以再放函數，沒問題的，生命週期也僅限於相同的一個 Code Block 裡使用</p><pre><code class="swift">func 香腸產生器() {  // code    func 調味() {    // code  }  調味()  }</code></pre><h2 id="傳址呼叫-Call-By-Reference"><a href="#傳址呼叫-Call-By-Reference" class="headerlink" title="傳址呼叫 Call By Reference"></a>傳址呼叫 Call By Reference</h2><h2 id="函數的參數中帶有-inout"><a href="#函數的參數中帶有-inout" class="headerlink" title="函數的參數中帶有 inout??"></a>函數的參數中帶有 inout??</h2><pre><code class="swift">func 肉肉加工函數(肉: 豬肉)-&gt; 豬肉 {  //bla bla bla  //肉 = 處理好的肉？？？  //如果你想把傳進來的肉再次地賦值，會發現不會成功  //因為此時傳進來的"肉" 是以 let 存在的變數  //  let 處理好的肉 = 肉+肉+肉  return 處理好的肉}//另一種寫法func 肉肉加工函數(肉: inout 豬肉) { //這裡多 inout  //肉 就不是 let 型式了， 而是指向記憶體位置的 var  肉 = 處理好的肉}//呼叫方式有點不同var 將要被處理的肉 : 肉肉肉加工函數(肉: &amp;將要被處理的肉)  //多了一個&amp;在變數前面print(將要被處理的肉)   // 其實變成處理好的肉</code></pre><p>有關於傳址乎叫 Call ByReference 還是 / 傳值呼叫 Call ByValue</p><p>留待下下章 <a href="/2022/10/08/01-10-swift/">Reference Type / Value Type</a> 時再解釋。</p><h2 id="遞迴-Recursion"><a href="#遞迴-Recursion" class="headerlink" title="遞迴 Recursion"></a>遞迴 Recursion</h2><p>什麼是遞迴？ 原理其實很簡單，就是函數裡的處理過程中，再次呼叫自己的函數。</p><pre><code class="swift">func recurse() {  ... ...    recurse()  ...  ...     }recurse()</code></pre><p>停不下來？？ 對，這就是遞迴的重點，要有跳脫的機制，不然就會陷入無窮迴圈，不斷地呼叫，而造成記憶體堆疊而炸掉程式。</p><h3 id="經典範例1"><a href="#經典範例1" class="headerlink" title="經典範例1"></a>經典範例1</h3><pre><code class="swift">func cumulativeSum(_ number:Int) -&gt; Int {  if number == 1 {  //跳脫條件    return 1  }   //不符合條件就往下繼續  return number + cumulativeSum(number - 1)}print(cumulativeSum(5))</code></pre><h3 id="經典範例2"><a href="#經典範例2" class="headerlink" title="經典範例2"></a>經典範例2</h3><pre><code class="swift">func fibonacci(_ i:Int) -&gt; Int {  if i &lt;= 2 { return 1 }   return fibonacci(i - 1) + fibonacci(i - 2) }print(fibonacci(5))</code></pre><h2 id="函數多載-Overloading"><a href="#函數多載-Overloading" class="headerlink" title="函數多載(Overloading)"></a>函數多載(Overloading)</h2><p>實務經驗中，函數的功能一樣，但有可能輸入的參數的型別不同，那麼，要讓開發者在使用中儘量地不改變開發的習慣時，就會再多寫一個多載函數</p><pre><code class="swift">func calAge(_ age:Int){  ...}func calAge(_ age:String){  ...}//呼叫calAge(18)calAge("18")</code></pre><p>或者，參數的型別相同，但命名的別稱不同，使用的情境也不同。</p><pre><code class="swift">func calAge(bank age:Int){  ...}func calAge(householdAdmin age:int){  ...}//呼叫calAge(bank:18)calAge(householdAdmin:18)</code></pre><h2 id="閉包-Closure-也可以算是一種內聯函數（inline-function），或是匿名函數的表示方式-但有點篇幅-所以下一章再講"><a href="#閉包-Closure-也可以算是一種內聯函數（inline-function），或是匿名函數的表示方式-但有點篇幅-所以下一章再講" class="headerlink" title="閉包 Closure 也可以算是一種內聯函數（inline function），或是匿名函數的表示方式,但有點篇幅  所以下一章再講"></a>閉包 Closure 也可以算是一種內聯函數（inline function），或是匿名函數的表示方式,但有點篇幅  所以下一章再講</h2><h2 id="運算子方法-Operator-Method"><a href="#運算子方法-Operator-Method" class="headerlink" title="運算子方法(Operator Method)"></a>運算子方法(Operator Method)</h2><p>雖然和函數看起來關係不大，不過也稱得上是隱式的函數的終極簡化版，晚點有機會再說明。</p><h1 id="使用函數的好處"><a href="#使用函數的好處" class="headerlink" title="使用函數的好處"></a>使用函數的好處</h1><ol><li>簡化程式與重複利用</li><li>增加程式的可讀性</li><li>每個函數就像是積木一樣，一塊塊排好，就可以做出完整的功能</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本函數-介紹&quot;&gt;&lt;a href=&quot;#基本函數-介紹&quot; class=&quot;headerlink&quot; title=&quot;基本函數 - 介紹&quot;&gt;&lt;/a&gt;基本函數 - 介紹&lt;/h1&gt;&lt;p&gt;函數是一個，用以執行特殊目的一個程式區塊這是一個swift的基礎函數說明&lt;/p&gt;
&lt;pre&gt;</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - Strong, Weak and Unowned</title>
    <link href="https://ios.taipei/2022/10/06/01-08-1-swift/"/>
    <id>https://ios.taipei/2022/10/06/01-08-1-swift/</id>
    <published>2022-10-05T16:00:05.000Z</published>
    <updated>2022-10-21T01:20:28.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Strong-Weak-and-Unowned-介紹"><a href="#Strong-Weak-and-Unowned-介紹" class="headerlink" title="Strong, Weak and Unowned - 介紹"></a>Strong, Weak and Unowned - 介紹</h1><h2 id="Manual-Reference-Count-MRC-x2F-Automatic-Reference-Counting-ARC"><a href="#Manual-Reference-Count-MRC-x2F-Automatic-Reference-Counting-ARC" class="headerlink" title="Manual Reference Count - (MRC) / Automatic Reference Counting - (ARC)"></a>Manual Reference Count - (MRC) / Automatic Reference Counting - (ARC)</h2><p>這篇在介紹swift裡記憶體的管理機制</p><p>早前的手機，因為硬體資源的限制，對於記憶體的使用格外的珍惜，早期在 Objective-C / Xcode 4 的年代，每個變數的引用與操作 alloc、new、retain、release 都要手動的一個個計數，在撰寫程式時，以良好的習慣，儘可能地釋放出更多記憶體供程式運行。當然，萬一呼叫到已經釋放掉的變數，就直接 Crash，不好好釋放的話，記憶體堆疊到不夠用了 (Memory leak)，也是直接 Crash。</p><p>隨著硬體的進步，Apple 也慢慢將手動參考計數 轉往自動參考計數，慢慢地由autorelease,再演化成由系統透過 Strong, Weak , Unowned 來判斷記憶體回收的時機</p><h1 id="未完待續"><a href="#未完待續" class="headerlink" title="未完待續"></a>未完待續</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Strong-Weak-and-Unowned-介紹&quot;&gt;&lt;a href=&quot;#Strong-Weak-and-Unowned-介紹&quot; class=&quot;headerlink&quot; title=&quot;Strong, Weak and Unowned - 介紹&quot;&gt;&lt;/a&gt;Stron</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 閉包 (Closure)</title>
    <link href="https://ios.taipei/2022/10/06/01-08-2-swift/"/>
    <id>https://ios.taipei/2022/10/06/01-08-2-swift/</id>
    <published>2022-10-05T16:00:05.000Z</published>
    <updated>2022-10-20T16:15:35.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="閉包-Closure-介紹"><a href="#閉包-Closure-介紹" class="headerlink" title="閉包(Closure) - 介紹"></a>閉包(Closure) - 介紹</h1><p>這裡是學習 swift 的一個關卡，不要急，先理解，模仿，再求變化</p><p>Reference Type</p><h2 id="基本型態"><a href="#基本型態" class="headerlink" title="基本型態"></a>基本型態</h2><pre><code class="swift">{ (parameters) -&gt; returnType in   // statements}</code></pre><p>parameters: 由外部傳進來的參數<br>returnType: 要回傳的型別<br>in: 將宣告與程式區塊分離的介詞</p><p>來一個簡單的 hello world 範例</p><pre><code class="swift">var sayHi = { print("hello world")}sayHi()</code></pre><p>加入參數</p><pre><code class="swift">var sayHi = { (name:String) in print("hello world, \(name)!!")}sayHi("Sweetie")</code></pre><p>回傳值</p><pre><code class="swift">var sum = { (number1 :Int, number2:Int) in   number1 + number2}print(sum(3,5)) //8</code></pre><h2 id="進階變化"><a href="#進階變化" class="headerlink" title="進階變化"></a>進階變化</h2><p>把閉包當做是一個參數丟到函數裡</p><h3 id="範例1"><a href="#範例1" class="headerlink" title="範例1"></a>範例1</h3><p>假如要做一個計算機，裡面需要把兩個數做處理, 寫法如下</p><pre><code class="swift">let operatorAdd = {(n1:Int,n2:Int) in  return n1 + n2}func calculate(_ num1:Int,_ num2:Int,_ opertator:(Int,Int)-&gt;Int ) -&gt; Int{  return opertator(num1,num2)}print(calculate(3,5,operatorAdd)) //8</code></pre><p>如果要實作減法，那就寫一個減法的閉包放進去，就會兩數相減了，是不是很神奇？？？</p><pre><code class="swift">let operatorMinus = {(n1:Int,n2:Int) in  return n1 - n2}print(calculate(3,5,operatorMinus)) //-1</code></pre><h3 id="經典範例2"><a href="#經典範例2" class="headerlink" title="經典範例2"></a>經典範例2</h3><pre><code class="swift">var names = ["aki","bill","cat"]var compare = { (s1: String, s2: String) -&gt; Bool in    return s1 &lt; s2}print(names.sorted(by: compare)) //["cat","bill","aki"],//其中又可以省略成names.sorted(by:(s1,s2) in s1&lt;s2)//超省略names.sorted(by:{$0&lt;$1})//終極省略names.sorted(by: &lt;)  //Operator Methods//所以~~~ 範例 1 的函數，可以省略成calculate(3,8,+)  //11calculate(3,8,-)  //-5//傑克，真是太神奇了</code></pre><h2 id="尾隨閉包-Trailing-Closure"><a href="#尾隨閉包-Trailing-Closure" class="headerlink" title="尾隨閉包 Trailing Closure"></a>尾隨閉包 Trailing Closure</h2><p>當閉包做為函數的參數，又剛好是最後一個的時候，就稱之為<span style="color:blue">尾隨閉包</span>，為什麼要介紹這個呢？因為 swift 很好心的想要簡略一些寫法。</p><p>先來一個變化前的函數</p><p>香腸產生器，將調味函數做成一個閉包參數，結果如下</p><pre><code class="swift">var seasoning = {    print("加鹽巴")}func sausageGenerator(meat:String,closureSeasoning: () -&gt; ()) {    print(meat)    closureSeasoning()    })//呼叫sausageGenerator("肉肉",seasoning)//有些閉包的寫法 可以省略 ()-&gt;() 直接寫成 {}sausageGenerator("肉肉",closureSeasoning:{print("加醬油")})</code></pre><p>因為閉包是最後一個參數，在呼叫函數時也可以改寫為 </p><pre><code class="swift">sausageGenerator(meat:meat) {  //原本放在 closureSeasoning 閉包裡的內容 就可以寫在這裡了  print("加胡椒")})</code></pre><h2 id="捕獲值-Capture-Value"><a href="#捕獲值-Capture-Value" class="headerlink" title="捕獲值 Capture Value"></a>捕獲值 Capture Value</h2><p>在閉包裡的程式區塊之中，在記憶體還沒回收之前，儲存的值是一直存在的，我們稱之為捕獲，舉例如下：</p><pre><code class="swift">//函數會產生一個加鹽巴的閉包func addSalt() -&gt; () -&gt; Void {    var saltCount = 1    return {        print("加了 \(saltCount) 次鹽巴")        saltCount += 1    }}//做一個閉包來使用var addSaltClosure = addSalt()sausageGenerator(meat:"肉",closureSeasoning:addSaltClosure)sausageGenerator(meat:"肉",closureSeasoning:addSaltClosure)sausageGenerator(meat:"肉",closureSeasoning:addSaltClosure)sausageGenerator(meat:"肉",closureSeasoning:addSaltClosure)////肉//加了 1 次鹽巴//肉//加了 2 次鹽巴//肉//加了 3 次鹽巴//肉//加了 4 次鹽巴</code></pre><p>發現了一個有趣的結果，saltCount 的值是一直被捕獲在閉包的程式區塊之中，隨著程式執行四次，就被遞增了四次。意即變數會一直被抓住，直到這個閉包被記憶體釋放後，saltCount 才會被消失。</p><p>那麼, 如果我們把程式外部的值傳到閉包裡，外部的值如果在閉包裡被捕獲，又要在外部修改，在這個當下就會產生程式的衝突，一個要拿，一個卻緊緊不放。</p><p>為了解決這個問題，請看另一個章節 <a href="/2022/10/06/01-08-1-swift/">swift 語言的特性 (Strong, Weak, UnOwned)</a></p><h2 id="非逃逸閉包-NoEscape-Closure"><a href="#非逃逸閉包-NoEscape-Closure" class="headerlink" title="非逃逸閉包 NoEscape Closure"></a>非逃逸閉包 NoEscape Closure</h2><p>當我們把閉包當做是一個參數丟到函數裡的時候，而在函數執行返回之後，才會繼續執行閉包，如果很明確的只要閉包乖乖當一個參數，生命週期只在函數裡完成，不再使用 reference type 的特性，將裡面的值接著向外操作，那麼只要加上個 @noescape 的前綴，就可以限制閉包的逃逸</p><pre><code class="swift">var seasoning = {    print("加鹽巴")}func sausageGenerator(meat:String, @noescape closureSeasoning: () -&gt; ()) {    print(meat)    closureSeasoning()    })</code></pre><h2 id="自動閉包-Auto-Closure"><a href="#自動閉包-Auto-Closure" class="headerlink" title="自動閉包 Auto Closure"></a>自動閉包 Auto Closure</h2><p>範例如下：</p><pre><code class="swift">func sausageGenerator(meat:String,season: @autoclosure () -&gt; ()) { greet()}// pass closure without {}sausageGenerator(meat: "肉", season: print("加鹽巴"))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;閉包-Closure-介紹&quot;&gt;&lt;a href=&quot;#閉包-Closure-介紹&quot; class=&quot;headerlink&quot; title=&quot;閉包(Closure) - 介紹&quot;&gt;&lt;/a&gt;閉包(Closure) - 介紹&lt;/h1&gt;&lt;p&gt;這裡是學習 swift 的一個關卡，不要</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 集合 (Collections)</title>
    <link href="https://ios.taipei/2022/10/05/01-06-swift/"/>
    <id>https://ios.taipei/2022/10/05/01-06-swift/</id>
    <published>2022-10-04T16:00:05.000Z</published>
    <updated>2022-10-11T08:50:52.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="陣列-Array"><a href="#陣列-Array" class="headerlink" title="陣列 (Array)"></a>陣列 (Array)</h1><p>有序的容器，可以包含相同的值</p><pre><code class="swift">var numbers : [Int] = [1, 2, 3, 4]//取值print(numbers[0])print(numbers[2])</code></pre><h2 id="陣列的基本操作"><a href="#陣列的基本操作" class="headerlink" title="陣列的基本操作"></a>陣列的基本操作</h2><table><thead><tr><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>append()</td><td>新增元素</td></tr><tr><td>remove(at:)</td><td>移除元素</td></tr><tr><td>removeAll()</td><td>移除所有元素</td></tr><tr><td>insert(,at:)</td><td>插入元素</td></tr><tr><td>sort(by:)</td><td>排序</td></tr><tr><td>shuffle()</td><td>洗亂順序</td></tr><tr><td>forEach()</td><td>反覆依序取出元素</td></tr><tr><td>contains()</td><td>找出包含有關的元素</td></tr><tr><td>first(where:)</td><td>找出第一個符合條件的元素</td></tr><tr><td>joined(separator:)</td><td>將陣列的所有元素以分隔符號串起為字串</td></tr><tr><td>swapAt()</td><td>交換元素的位置</td></tr><tr><td>reversed()</td><td>反序排列</td></tr><tr><td>count</td><td>陣列長度</td></tr><tr><td>isEmpty</td><td>陣列是否為空</td></tr><tr><td>randomElement()</td><td>隨機給一個元素</td></tr></tbody></table><p>值的修改就在該位置做賦值，就會蓋過去了</p><pre><code>numbers[2] = 5</code></pre><h2 id="陣列的迴圈"><a href="#陣列的迴圈" class="headerlink" title="陣列的迴圈"></a>陣列的迴圈</h2><pre><code class="swift">for i in numbers {  print(i)}</code></pre><h1 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合 Sets"></a>集合 Sets</h1><p>無序的容器，所存放的值必須不同</p><pre><code class="swift">var numberSet : Set = [112, 114, 115, 116, 117]</code></pre><h2 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h2><table><thead><tr><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>contains()</td><td>找出包含有關的元素</td></tr><tr><td>insert(,at:)</td><td>插入元素</td></tr><tr><td>first(where:)</td><td>找出第一個符合條件的元素</td></tr><tr><td>joined(separator:)</td><td>將組合的所有元素以分隔符號串起為字串</td></tr><tr><td>remove(at:)</td><td>移除元素</td></tr><tr><td>forEach()</td><td>反覆依序取出元素</td></tr><tr><td>sort()</td><td>排序</td></tr><tr><td>reversed()</td><td>反序排列</td></tr><tr><td>count</td><td>陣列長度</td></tr><tr><td>isEmpty</td><td>陣列是否為空</td></tr><tr><td>randomElement()</td><td>隨機給一個元素</td></tr></tbody></table><h2 id="集合的迴圈"><a href="#集合的迴圈" class="headerlink" title="集合的迴圈"></a>集合的迴圈</h2><pre><code class="swift">for s in numbersSet {  print(s)}</code></pre><h2 id="集合的特殊操作"><a href="#集合的特殊操作" class="headerlink" title="集合的特殊操作"></a>集合的特殊操作</h2><p>假設兩個集合為已知</p><pre><code class="swift">// first setlet setA: Set = [1, 2, 3]// second setlet setB: Set = [2, 3, 4]</code></pre><h3 id="聯集-Union"><a href="#聯集-Union" class="headerlink" title="聯集 (Union)"></a>聯集 (Union)</h3><p><img src="/images/swift-set-union.png"></p><pre><code class="swift">print("Union: ", setA.union(setB))</code></pre><h3 id="交集-Intersection"><a href="#交集-Intersection" class="headerlink" title="交集 (Intersection)"></a>交集 (Intersection)</h3><p><img src="/images/swift-set-intersect.png"></p><pre><code class="swift">print("Intersection: ", setA.intersection(setB))</code></pre><h3 id="差集-Difference"><a href="#差集-Difference" class="headerlink" title="差集 (Difference)"></a>差集 (Difference)</h3><p><img src="/images/swift-set-difference.png"></p><pre><code class="swift">print("Subtracting: ", setA.subtracting(setB))</code></pre><h3 id="對稱差集-Symmetric-Difference"><a href="#對稱差集-Symmetric-Difference" class="headerlink" title="對稱差集 (Symmetric Difference )"></a>對稱差集 (Symmetric Difference )</h3><p><img src="/images/swift-set-symmetric-difference.png"></p><pre><code class="swift">print("Symmetric Difference: ", setA.symmetricDifference(setB))</code></pre><h3 id="檢查子集合-isSubset"><a href="#檢查子集合-isSubset" class="headerlink" title="檢查子集合 (isSubset)"></a>檢查子集合 (isSubset)</h3><pre><code class="swift">print("isSubset: ", setA.isSubset(of:setB))</code></pre><h3 id="檢查相等-equal"><a href="#檢查相等-equal" class="headerlink" title="檢查相等 (equal)"></a>檢查相等 (equal)</h3><pre><code class="swift">print("is Equal: ", setA == setB)</code></pre><h1 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 Dictionary"></a>字典 Dictionary</h1><p>存儲資料是以 key - value 的型式存在</p><p>範例：</p><pre><code class="swift">var telCode = ["Taiwan":"+886","US":"+1"]</code></pre><h2 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h2><p>增加元素（修改元素）</p><pre><code class="swift">telCode["Japan"] = "+81"</code></pre><p>取得所有的 keys</p><pre><code class="swift">var countryName  = Array(telCode.keys)</code></pre><p>取得所有的 value</p><pre><code class="swift">var values  = Array(telCode.values)</code></pre><p>用 key 來移除資料</p><pre><code class="swift">telCode.removeValue(forKey: "US")</code></pre><h2 id="其他的基本操作"><a href="#其他的基本操作" class="headerlink" title="其他的基本操作"></a>其他的基本操作</h2><table><thead><tr><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>count</td><td>字典長度</td></tr><tr><td>first(where:)</td><td>找出第一個符合條件的元素</td></tr><tr><td>isEmpty</td><td>陣列是否為空</td></tr><tr><td>contains()</td><td>找出包含有關的元素</td></tr><tr><td>remove(at:)</td><td>移除元素</td></tr><tr><td>forEach()</td><td>反覆依序取出元素</td></tr><tr><td>sort()</td><td>排序</td></tr><tr><td>reversed()</td><td>反序排列</td></tr><tr><td>randomElement()</td><td>隨機給一個元素</td></tr><tr><td>shuffle()</td><td>洗亂順序</td></tr></tbody></table><h1 id="元組-tuple"><a href="#元組-tuple" class="headerlink" title="元組(tuple)"></a>元組(tuple)</h1><pre><code class="swift">//一個簡單的元組var productTuple = ("MacBook", 1099.99)print(productTuple.0)print(productTuple.1)//有名字的元組var productTuple = (name: "MacBook", price: 1399.99)print(productTuple.name)print(productTuple.price)//巢狀元組var alphabets = ("A", "B", "C", ("a", "b", "c"))//第 0 個   // 印出 "A"print(alphabets.0) //第 3 個  // 印出 ("a", "b", "c")print(alphabets.3)//第 3 個元組的第 1 個print(alphabets.3.0)  // 印出 "a"</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;陣列-Array&quot;&gt;&lt;a href=&quot;#陣列-Array&quot; class=&quot;headerlink&quot; title=&quot;陣列 (Array)&quot;&gt;&lt;/a&gt;陣列 (Array)&lt;/h1&gt;&lt;p&gt;有序的容器，可以包含相同的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 運算子 Operators</title>
    <link href="https://ios.taipei/2022/10/04/01-05-swift/"/>
    <id>https://ios.taipei/2022/10/04/01-05-swift/</id>
    <published>2022-10-03T16:00:04.000Z</published>
    <updated>2022-10-11T06:42:56.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算術運算子-Arithmetic-Operator"><a href="#算術運算子-Arithmetic-Operator" class="headerlink" title="算術運算子 Arithmetic Operator"></a>算術運算子 Arithmetic Operator</h1><table><thead><tr><th>Operator 運算子</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>3 + 2 = 5</td></tr><tr><td>-</td><td>減</td><td>3 - 2 = 1</td></tr><tr><td>*</td><td>乘</td><td>3 * 2 = 6</td></tr><tr><td>/</td><td>除</td><td>5 / 2 = 2</td></tr><tr><td>%</td><td>求餘</td><td>5 % 3 = 2</td></tr></tbody></table><h1 id="指派運算子-Assignment-Operator"><a href="#指派運算子-Assignment-Operator" class="headerlink" title="指派運算子 Assignment Operator"></a>指派運算子 Assignment Operator</h1><table><thead><tr><th>Operator 運算子</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td>=</td><td>右邊的值指派給左邊的變數</td><td>a = 7</td></tr><tr><td>+=</td><td>先加 再指派</td><td>a += 1    // a = a + 1</td></tr><tr><td>-=</td><td>先減 再指派</td><td>a -= 3.   // a = a - 3</td></tr><tr><td>*=</td><td>先乘 再指派</td><td>a *= 4    // a = a * 4</td></tr><tr><td>/=</td><td>先除 再指派</td><td>a /= 3    // a = a / 3</td></tr><tr><td>%=</td><td>先求餘數 再指派</td><td>a /= 3    // a = a / 3</td></tr></tbody></table><h1 id="比較運算子-Comparison-Operators"><a href="#比較運算子-Comparison-Operators" class="headerlink" title="比較運算子 Comparison Operators"></a>比較運算子 Comparison Operators</h1><table><thead><tr><th>Operator 運算子</th><th>說明</th><th>範例</th><th>返回值</th></tr></thead><tbody><tr><td>==</td><td>相等</td><td>3 == 5</td><td>false</td></tr><tr><td>!=</td><td>不相等</td><td>3 != 5</td><td>true</td></tr><tr><td>&gt;</td><td>大於</td><td>3 &gt; 5</td><td>false</td></tr><tr><td>&lt;</td><td>小於</td><td>3 &lt; 5</td><td>true</td></tr><tr><td>&gt;=</td><td>大於等於</td><td>3 &gt;= 5</td><td>false</td></tr><tr><td>&lt;=</td><td>小於等於</td><td>3&lt;=5</td><td>true</td></tr></tbody></table><h1 id="邏輯運算子-Logical-Operators"><a href="#邏輯運算子-Logical-Operators" class="headerlink" title="邏輯運算子 Logical Operators"></a>邏輯運算子 Logical Operators</h1><table><thead><tr><th>Operator 運算子</th><th>說明</th><th>範例</th><th>說明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>且</td><td>a &amp;&amp; b</td><td>Logical AND 當a和b都是true 時才是 true</td></tr><tr><td>||</td><td>或</td><td>a || b</td><td>Logical OR 當a或b，只要其中一個為true 時就是 true</td></tr><tr><td>!</td><td>相反</td><td>!a</td><td>邏輯相反</td></tr></tbody></table><h1 id="按位運算子-Bitwise-Operators"><a href="#按位運算子-Bitwise-Operators" class="headerlink" title="按位運算子 Bitwise Operators"></a>按位運算子 Bitwise Operators</h1><table><thead><tr><th>Operator 運算子</th><th>說明</th></tr></thead><tbody><tr><td>&amp;</td><td>Binary AND</td></tr><tr><td>|</td><td>Binary OR</td></tr><tr><td>^</td><td>Binary XOR</td></tr><tr><td>~</td><td>Binary One’s Complement</td></tr><tr><td>&lt;&lt;</td><td>Binary Shift Left</td></tr><tr><td>&gt;&gt;</td><td>Binary Shift Right</td></tr></tbody></table><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><table><thead><tr><th>Operator 運算子</th><th>說明</th><th>範例</th><th>返回值</th></tr></thead><tbody><tr><td>? :</td><td>三元判斷式</td><td>let s = (3 &gt; 5) ? “Success” : “Error”</td><td>“Success”</td></tr><tr><td>??</td><td>空值合併判斷式</td><td>number ?? 5</td><td>當 number 為 nil 時 返回 5， 當number 不為 nil 時 返回 number</td></tr><tr><td>…</td><td>範圍表示式</td><td>1…5</td><td>返回 1,2,3,4,5</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算術運算子-Arithmetic-Operator&quot;&gt;&lt;a href=&quot;#算術運算子-Arithmetic-Operator&quot; class=&quot;headerlink&quot; title=&quot;算術運算子 Arithmetic Operator&quot;&gt;&lt;/a&gt;算術運算子 Arith</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - nil / optional / unwrap</title>
    <link href="https://ios.taipei/2022/10/03/01-04-swift/"/>
    <id>https://ios.taipei/2022/10/03/01-04-swift/</id>
    <published>2022-10-02T16:00:03.000Z</published>
    <updated>2022-10-14T07:58:35.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空值-nil-x2F-optional-x2F-unwrap（-）"><a href="#空值-nil-x2F-optional-x2F-unwrap（-）" class="headerlink" title="空值(nil)/ optional(?) / unwrap（!）"></a>空值(nil)/ optional(?) / unwrap（!）</h1><h2 id="什麼是空值"><a href="#什麼是空值" class="headerlink" title="什麼是空值"></a>什麼是空值</h2><p>如果要舉一個生活中的例子，程式裡的變數，就像是一個裝著鞋子的鞋盒(optional)，變數裡面的值，就是鞋子。程式在運作或傳遞變數時，是將鞋盒傳來傳去，如果需要對值做一些變化的時候，才會把鞋子從鞋盒拿出來(wrap)，整理好再放回去鞋盒裡去。如果鞋盒裡沒有鞋子(nil),那麼，執恴要把鞋子給拿出來，就會造成程式執行錯誤，或者是crash。</p><h2 id="why-Optional"><a href="#why-Optional" class="headerlink" title="why Optional"></a>why Optional</h2><p>程式在取用變數時，有一定的機率會遇到變收尚未初始化或尚未賦值，程式取不到值，而發生異常或是直接CRASH的狀況發生，為了防止意外，可以假設設定每個變數都有可以是不存的，所以就會在型別的後綴加一個問題，來表示 optional, 100% 確定有值的，就不用 optional, 就可以用很快的速度，不一一檢查變數，直接執行程式。</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><pre><code class="swift">Int? i = 1String? s = "aaa"Double? d = 0.1</code></pre><p>在確定有值的時候，(強迫？)取值的方式為</p><pre><code class="swift">print(i!)//output   1print(s!)//output   "aaa"print(d!)//output   0.1</code></pre><p>如果不加(！),取值的結果就會不一樣</p><pre><code class="swift">print(i)//output    optional(1)print(s)//output    optional("sss")print(d)//output    optional(0.1)</code></pre><h2 id="optional-的特性"><a href="#optional-的特性" class="headerlink" title="optional ? 的特性"></a>optional ? 的特性</h2><p>如果在等號的左邊有個?，那麼如果變數為 nil 時， 則整行不會被執行</p><pre><code class="swift">var abc = nilabc?.text = "123" //將不會執行</code></pre><h2 id="現實生活中的型別安全"><a href="#現實生活中的型別安全" class="headerlink" title="現實生活中的型別安全"></a>現實生活中的型別安全</h2><p>那麼，到底什麼時候要用 optional，什麼時候不用呢？ 舉個生活中的例子來說，手機APP裡，使用 http request 與 伺服器端溝通， 當收到 API 的http response, 大部份是回覆 json 格式的 response, 手機再接著畫出UI的呈現。但是，server api 其實沒想像中的可靠，萬一少回了一個欄位呢？，萬一回的欄位的型別不對了呢？所以，只要是未知的變數，絕大部份都會做型別安全的保護，讓程式不會因為壞掉而無法繼續運作。</p><p>以下有幾種不同的 optional binding寫法</p><p>範例 1</p><pre><code class="swift">String? s = "aaa"if s != nil {    //如果鞋盒裡有鞋子的話, 就拿出來，並且命名為 s1，    //s1 在這個 code block 的生命週期裡，就隨時可取用，不用擔心程式爆炸 } else {    //鞋盒裡沒有鞋子，不要想了}</code></pre><p>範例 2</p><pre><code class="swift">String? s = "aaa"if let s1 = s {    //如果鞋盒裡有鞋子的話, 就拿出來，並且命名為 s1，    //s1 在這個 code block 的生命週期裡，就隨時可取用，不用擔心程式爆炸 } else {    //鞋盒裡沒有鞋子，不要想了}</code></pre><p>範例 3</p><pre><code class="swift">String? s = "aaa"guard let s1 = s else {    //鞋盒裡沒有鞋子，不要繼續了    return}    //s1 在這個 guard let 之後，就隨時可取用，不用擔心程式爆炸 </code></pre><p>範例 4</p><p>Nil-coalescing operator</p><pre><code class="swift">String? s = "aaa"let s1 : String = s ?? ""</code></pre><p>如果 s 不是 nil 的話。則 s1 = s 裡的值。不然的話。s1是預設值  “” ( 空字串 ) </p><p>然後 s1 就有值了，  不管是不是 s 鞋盒裡的值， 但至少不會壞掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;空值-nil-x2F-optional-x2F-unwrap（-）&quot;&gt;&lt;a href=&quot;#空值-nil-x2F-optional-x2F-unwrap（-）&quot; class=&quot;headerlink&quot; title=&quot;空值(nil)/ optional(?) / unw</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 流程控制</title>
    <link href="https://ios.taipei/2022/10/02/01-03-swift/"/>
    <id>https://ios.taipei/2022/10/02/01-03-swift/</id>
    <published>2022-10-01T16:00:02.000Z</published>
    <updated>2022-10-11T08:45:19.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程式語言常用的流程控制"><a href="#程式語言常用的流程控制" class="headerlink" title="程式語言常用的流程控制"></a>程式語言常用的流程控制</h1><h2 id="條件式陳述-Conditional-Statement"><a href="#條件式陳述-Conditional-Statement" class="headerlink" title="條件式陳述 Conditional Statement"></a>條件式陳述 Conditional Statement</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><pre><code class="swift">var age = 25if (age &gt; 20) {  print("可以結婚了")} else if (age &gt; 18){  print("可以投票了")} else {  print("乖乖等長大")}</code></pre><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><pre><code class="swift">let dayOfWeek = 4switch dayOfWeek {  case 1:    print("Sunday")          case 2:    print("Monday")          case 3:    print("Tuesday")          case 4:    print("Wednesday")    fallthrough          case 5:    print("Thursday")          case 6:    print("Friday")          case 7:    print("Saturday")          default:    print("Invalid day")}</code></pre><p>條件可以是任何型別，數字範圍，文字，字典或元組</p><p>另外，有一個不常用 但還是知道一下比較好的參數</p><p>fallthrough 可以穿透一層 case</p><h2 id="迴圈式陳述-Loop-Statement"><a href="#迴圈式陳述-Loop-Statement" class="headerlink" title="迴圈式陳述 Loop Statement"></a>迴圈式陳述 Loop Statement</h2><h3 id="for-in-loop"><a href="#for-in-loop" class="headerlink" title="for-in-loop"></a>for-in-loop</h3><p>範例 1</p><pre><code class="swift">let languages = ["Flutter","Swift", "Kotlin"]for language in languages where language != "Kotlin" {      print(language)}</code></pre><p>範例 2</p><pre><code class="swift">for i in 1 ... 5 {    print(i)}</code></pre><pre><code class="swift">for i in 1 ..&lt; 5 {    print(i)}</code></pre><p>範例 3</p><pre><code class="swift">for i in stride(from: 1, to: 10, by: 2) {    print(i)}</code></pre><h3 id="Nest-for-in-loop-巢狀迴圈、跳過-continue-與中斷-break"><a href="#Nest-for-in-loop-巢狀迴圈、跳過-continue-與中斷-break" class="headerlink" title="Nest for-in-loop 巢狀迴圈、跳過(continue)與中斷(break)"></a>Nest for-in-loop 巢狀迴圈、跳過(continue)與中斷(break)</h3><p>範例 1</p><pre><code class="swift">outerLoop: for i in 1...3{  innerLoop: for j in 1...3 {     if i==1 &amp;&amp; j == 3 {      continue outerLoop    }    if j == 3 {      break outerLoop    }      print("i = \(i), j = \(j)")  }}</code></pre><h3 id="while-loop"><a href="#while-loop" class="headerlink" title="while-loop"></a>while-loop</h3><p>範例 1</p><pre><code class="swift">var i = 1, n = 5while (i &lt;= n) {  print(i)   i = i + 1}</code></pre><p>範例 2</p><pre><code class="swift">var i = 1, n = 5repeat {    print(i)  i = i + 1} while (i &lt;= n)</code></pre><h3 id="保護式陳述-guard-statement"><a href="#保護式陳述-guard-statement" class="headerlink" title="保護式陳述 guard statement"></a>保護式陳述 guard statement</h3><p>範例 1</p><pre><code class="swift">func checkOddEven() {  var number = 7  guard number % 2 == 0 else {        print("奇數")    return  }  print("偶數")}</code></pre><p>範例 2</p><pre><code class="swift">func checkNumber() {      var number? = 7    guard let myNumber = number else {        print("number is undefined")    return  }  guard number % 2 == 0 else {        print("奇數")    return  }  print("偶數")}</code></pre><p>型別後出現了一個問號，請看下一篇文章  swift: Type Safe</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程式語言常用的流程控制&quot;&gt;&lt;a href=&quot;#程式語言常用的流程控制&quot; class=&quot;headerlink&quot; title=&quot;程式語言常用的流程控制&quot;&gt;&lt;/a&gt;程式語言常用的流程控制&lt;/h1&gt;&lt;h2 id=&quot;條件式陳述-Conditional-Statement&quot;&gt;</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 註解、程式區塊與標記</title>
    <link href="https://ios.taipei/2022/10/01/01-02-swift/"/>
    <id>https://ios.taipei/2022/10/01/01-02-swift/</id>
    <published>2022-09-30T16:00:01.000Z</published>
    <updated>2022-10-11T08:44:28.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h1><h2 id="單行註解"><a href="#單行註解" class="headerlink" title="單行註解"></a>單行註解</h2><pre><code class="swift">// 我是一行註解</code></pre><h2 id="多行註解"><a href="#多行註解" class="headerlink" title="多行註解"></a>多行註解</h2><pre><code class="swift">/* 我是多行註解 */</code></pre><p>基本上 第一個 /* 之後，會找到與之對稱的 */ 做為結束</p><h1 id="程式區塊（Code-Block）"><a href="#程式區塊（Code-Block）" class="headerlink" title="程式區塊（Code Block）"></a>程式區塊（Code Block）</h1><p>絕大部份的程式都有區塊的概念，舉例來說</p><pre><code class="swift">if condition {   //區塊開始。。。} //區塊結束</code></pre><h1 id="Xcode-標記（MARK、TODO、FIXME）"><a href="#Xcode-標記（MARK、TODO、FIXME）" class="headerlink" title="Xcode 標記（MARK、TODO、FIXME）"></a>Xcode 標記（MARK、TODO、FIXME）</h1><h2 id="MARK"><a href="#MARK" class="headerlink" title="MARK"></a>MARK</h2><pre><code class="swift">// MARK: 測試1 不帶分隔線func test1() {}</code></pre><p>多了一個 dash</p><pre><code class="swift">// MARK: - 測試2 帶分隔線func test2() {}</code></pre><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><pre><code class="swift">func test3() {// TODO: - 待做}</code></pre><h2 id="FIXME"><a href="#FIXME" class="headerlink" title="FIXME"></a>FIXME</h2><pre><code class="swift">func test4() {// FIXME: - 不修會壞掉}</code></pre><h2 id="看一下範例"><a href="#看一下範例" class="headerlink" title="看一下範例"></a>看一下範例</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/01-02-swift.png" alt="範例"></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;註解&quot;&gt;&lt;a href=&quot;#註解&quot; class=&quot;headerlink&quot; title=&quot;註解&quot;&gt;&lt;/a&gt;註解&lt;/h1&gt;&lt;h2 id=&quot;單行註解&quot;&gt;&lt;a href=&quot;#單行註解&quot; class=&quot;headerlink&quot; title=&quot;單行註解&quot;&gt;&lt;/a&gt;單行註解&lt;/h</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift 語言的基礎 - 變數，常數</title>
    <link href="https://ios.taipei/2022/09/30/01-01-swift/"/>
    <id>https://ios.taipei/2022/09/30/01-01-swift/</id>
    <published>2022-09-29T16:00:00.000Z</published>
    <updated>2022-10-11T09:14:05.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程式語言常用的變數型別"><a href="#程式語言常用的變數型別" class="headerlink" title="程式語言常用的變數型別"></a>程式語言常用的變數型別</h1><h2 id="布林-Bool-、字符-Charater-、字串-String-、整數-Integer-和浮點數-Double、Float"><a href="#布林-Bool-、字符-Charater-、字串-String-、整數-Integer-和浮點數-Double、Float" class="headerlink" title="布林(Bool)、字符(Charater)、字串(String)、整數(Integer)和浮點數(Double、Float)"></a>布林(Bool)、字符(Charater)、字串(String)、整數(Integer)和浮點數(Double、Float)</h2><pre><code class="swift">var isOpen = truelet c = "a"let s = "我是一個字串"  var i = 1let d : Double = 0.5//試著印出來看看print(isOpen)print(c)print(s)print(i)print(d)</code></pre><h3 id="解釋-1"><a href="#解釋-1" class="headerlink" title="解釋 1"></a>解釋 1</h3><p>字串 (String) 其實就是 字符 (Character) 的 陣列 (Array)</p><h3 id="解釋-2"><a href="#解釋-2" class="headerlink" title="解釋 2"></a>解釋 2</h3><p>let 是常數的賦值關鍵字，意思為等號右邊的內容，放入 等號左邊 的名詞，等之後要用的時候，方便使用，但不能再次賦值或修改</p><p>var 是變數的賦值關鍵字，意思為等號右邊的內容，放入 等號左邊 的名詞，等之後要用的時候，方便使用，能夠多次賦值或修改</p><p>如果型別是已知的話。在等號左邊 加上 <span style="color:red">: 型別 </span>，如果不加的話，型別則是會由右邊的值的型別來幫你決定。</p><h3 id="解釋-3"><a href="#解釋-3" class="headerlink" title="解釋 3"></a>解釋 3</h3><p>print 是一個 將內容輸出到除錯視窗 的 函數，常用來觀測數值的變化與除錯debug，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程式語言常用的變數型別&quot;&gt;&lt;a href=&quot;#程式語言常用的變數型別&quot; class=&quot;headerlink&quot; title=&quot;程式語言常用的變數型別&quot;&gt;&lt;/a&gt;程式語言常用的變數型別&lt;/h1&gt;&lt;h2 id=&quot;布林-Bool-、字符-Charater-、字串-Stri</summary>
      
    
    
    
    <category term="swift" scheme="https://ios.taipei/categories/swift/"/>
    
    
    <category term="swift" scheme="https://ios.taipei/tags/swift/"/>
    
    <category term="新手" scheme="https://ios.taipei/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>開發環境介紹</title>
    <link href="https://ios.taipei/2022/09/29/00-01-devTool/"/>
    <id>https://ios.taipei/2022/09/29/00-01-devTool/</id>
    <published>2022-09-28T16:00:00.000Z</published>
    <updated>2022-10-11T06:42:49.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="開發-App-的所需工具"><a href="#開發-App-的所需工具" class="headerlink" title="開發 App 的所需工具"></a>開發 App 的所需工具</h1><p>　　<b><b>Apple</b></b> 系統是一個封閉式的系統，因此，<b>App</b> 想要運行在蘋果的裝置上的話，就必須要使用 <b>Apple</b> 的 <b>OS</b> 以及 開發工具 <b>Xcode</b> 進行打包與上架。同時也可以開發 <b>Android</b> 相關的 <b>App</b>。雖然 <b>Android</b> 的開發，可以使用 <b>windows</b> 系統，但是一旦你選擇了 <b>windows</b> 系統，那麼你就等於放棄了開發 <b>Apple</b> 的市場。因此，在對於開發者的系統選擇上，我只推薦 <b>Mac</b> 來進行 <b>App</b> 開發。</p><p>　　工欲善其事，必先利其器，好用的工具能夠讓開發者節省時間，以下是在開發之前，你要事先準備好：</p><h2 id="硬體"><a href="#硬體" class="headerlink" title="硬體"></a>硬體</h2><h3 id="Mac-電腦"><a href="#Mac-電腦" class="headerlink" title="Mac 電腦"></a>Mac 電腦</h3><ul><li><b>Mac Book Pro</b></li><li><b>Mac Mini</b></li><li><s> Mac Book Air </s></li><li><s> 黑蘋果 </s></li></ul><h4 id="MBP-挑選的重點"><a href="#MBP-挑選的重點" class="headerlink" title="MBP 挑選的重點:"></a>MBP 挑選的重點:</h4><p>RAM - 8G 最低。 16G 開發就不太會有卡頓感，32G的話。同時跑很多程式沒問題</p><p>CPU - CPU 各有優劣， Intel / M1 / M2 … 當下能挑選的其實不多</p><p>硬碟空間 - 256 G 對於開發者是絕對不夠的， 512G 的應該就足夠開發</p><p>螢幕大小 - 13吋 / 14 吋 / 16吋。 大的看起來舒服，但是重！！！</p><h4 id="Mini-挑選的重點"><a href="#Mini-挑選的重點" class="headerlink" title="Mini 挑選的重點:"></a>Mini 挑選的重點:</h4><p>同上，只是沒有螢幕，不能移動</p><h4 id="Air"><a href="#Air" class="headerlink" title="Air"></a>Air</h4><p>文書機，不建議用來開發，因為沒有風扇，CPU 會因為熱 而導致降頻。手放在鍵盤上很有感覺。</p><p>另外 TYPE-C 接頭只有二個，透過外接的HUB外接螢幕，再同時裝手機進行偵錯，偶而會有BUILD到一半斷線的可能性。</p><h3 id="測試機"><a href="#測試機" class="headerlink" title="測試機"></a>測試機</h3><ul><li>iPhone</li><li>iPad</li><li>傳輸線</li><li>模擬器</li></ul><h3 id="建議"><a href="#建議" class="headerlink" title="建議"></a>建議</h3><p>再差的手機也會比模擬器好</p><h2 id="軟體"><a href="#軟體" class="headerlink" title="軟體"></a>軟體</h2><ul><li><b>Mac OS</b></li><li><b>Xcode</b></li></ul><h2 id="帳號"><a href="#帳號" class="headerlink" title="帳號"></a>帳號</h2><ul><li><b>Apple ID (Email) </b></li><li><b>Apple Developer Program</b></li><li><b>Apple Developer Enterprise Program (特殊情況下使用)</b></li></ul><hr><p>　　在開發 <b>APP</b> 之前，我們可以先算一下成本，要先買電腦，要先買手機，要每年付開發者上架的年費<br><b>Apple STORE</b> 參考價格</p><p>開發機 擇1</p><ul><li><a href="https://www.apple.com/tw/shop/buy-mac/macbook-pro/16-%E5%90%8B">MBP</a> 16吋 <b>NTD</b> $74,900</li><li><a href="https://www.apple.com/tw/shop/buy-mac/mac-mini">Mac Mini</a> <b>NTD</b> $27,900</li></ul><p><b>iPhone</b> 擇1 </p><ul><li><a href="https://www.apple.com/tw/shop/buy-iphone/iphone-se">iPhone SE</a>  <b>NTD</b> $14,900</li><li><a href="https://www.apple.com/tw/shop/buy-iphone/iphone-14-pro">iPhone 14 Pro</a> <b>NTD</b> $34,900</li></ul><p><b>Apple Developer Program</b></p><ul><li>每年 <b>NTD</b> $3,400. <a href="https://developer.apple.com/">(點此前往)</a></li></ul><h1 id="還沒開始寫程式，至少就已經噴了快10萬元新台幣"><a href="#還沒開始寫程式，至少就已經噴了快10萬元新台幣" class="headerlink" title="還沒開始寫程式，至少就已經噴了快10萬元新台幣"></a>還沒開始寫程式，至少就已經噴了快10萬元新台幣</h1><p>沒錯，若是你選擇用 <b>Windows</b> 來開發 <b>Android</b> 的話，也不是不行，只是這裡剛好不適合你。。。。咦？ </p><p>先想想。開發 <b>App</b> 是為了什麼? </p><ol><li>錢</li><li>興趣</li><li>工作與生活的平衡</li></ol><p>撇去興趣這種主觀的判斷，薪水在初階工程師，是差不多的，但是以稀缺性而言，<b>iOS</b> 的工程師因為進入門檻高，所以人少，因此，可以選擇的工作機會會比較多，因此更有條件找到喜歡的工作。</p><p>長期而言，如果想要再向上突破，雙刀流 (<b>iOS/Android</b>) 也是一條往更高的職位前進的方法。</p><p>職場有一種都市傳說，就是</p><ol><li><p><b>123</b> 法則</p><p> 1 個人 - 領 2 份薪水 - 做 3 份工作</p></li><li><p><b>234</b> 法測</p><p> 2 個人 - 領 3 份薪水 - 做 4 份工作</p></li></ol><p>當你為你的人生做了一個重大選擇，那麼下一步是什麼？下下步呢？</p><p>如果你還是想選 <b>Android</b> 開發，當然 我會推薦你不同的選擇，留到 <b>Android</b> 開發的章節再聊。</p><p>PS。 </p><p>錢夠的話。我只推薦 <span style="color:red"><b>頂規</b></span> </p><p>BUILD CODE 快，思維不會被打斷，不用等的感覺，真的是工程師的夢想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;開發-App-的所需工具&quot;&gt;&lt;a href=&quot;#開發-App-的所需工具&quot; class=&quot;headerlink&quot; title=&quot;開發 App 的所需工具&quot;&gt;&lt;/a&gt;開發 App 的所需工具&lt;/h1&gt;&lt;p&gt;　　&lt;b&gt;&lt;b&gt;Apple&lt;/b&gt;&lt;/b&gt; 系統是一個封閉式</summary>
      
    
    
    
    <category term="開發環境" scheme="https://ios.taipei/categories/%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    
    <category term="開發環境" scheme="https://ios.taipei/tags/%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="Mac" scheme="https://ios.taipei/tags/Mac/"/>
    
    <category term="Xcode" scheme="https://ios.taipei/tags/Xcode/"/>
    
    <category term="Apple ID" scheme="https://ios.taipei/tags/Apple-ID/"/>
    
    <category term="Apple Developer Program" scheme="https://ios.taipei/tags/Apple-Developer-Program/"/>
    
  </entry>
  
</feed>
