{"meta":{"title":"iOS @ Taipei","subtitle":"iOS and his good friends","description":"We are the guys who fall in love with iOS","author":"AKI YU","url":"http://ios.taipei"},"pages":[{"title":"about","date":"2015-05-08T06:12:14.000Z","updated":"2015-05-08T06:15:44.000Z","comments":true,"path":"APP.html","permalink":"http://ios.taipei/APP.html","excerpt":"","text":"Love to think,to talk and to have a cup of teafeel free to contact meCaviar0401 at gmail"},{"title":"about","date":"2015-05-08T06:12:14.000Z","updated":"2015-05-08T06:15:44.000Z","comments":true,"path":"About.html","permalink":"http://ios.taipei/About.html","excerpt":"","text":"Love to think,to talk and to have a cup of teafeel free to contact meCaviar0401 at gmail"}],"posts":[{"title":"Line X iOS 社群合辦分享會","slug":"LineXiOS","date":"2019-07-03T15:00:00.000Z","updated":"2019-10-13T04:20:28.790Z","comments":true,"path":"2019/07/03/LineXiOS/","link":"","permalink":"http://ios.taipei/2019/07/03/LineXiOS/","excerpt":"網路世界裡有許許多多不同層級的cache 要能夠保留cache的機制，又得隨心所欲的更新，就得多了解背後運作的原理。 投影片","text":"網路世界裡有許許多多不同層級的cache 要能夠保留cache的機制，又得隨心所欲的更新，就得多了解背後運作的原理。 投影片 https://github.com/ios-taipei/DataBed/raw/master/LineXiOS%40Taipei20190703.key","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"Network","slug":"Network","permalink":"http://ios.taipei/tags/Network/"},{"name":"httpDNS","slug":"httpDNS","permalink":"http://ios.taipei/tags/httpDNS/"},{"name":"Cache","slug":"Cache","permalink":"http://ios.taipei/tags/Cache/"}]},{"title":"新增行事曆的事件","slug":"calenderEvent","date":"2019-05-19T15:00:00.000Z","updated":"2019-10-12T06:56:04.203Z","comments":true,"path":"2019/05/19/calenderEvent/","link":"","permalink":"http://ios.taipei/2019/05/19/calenderEvent/","excerpt":"Q: 想要加一個事件在行日曆上嗎？","text":"Q: 想要加一個事件在行日曆上嗎？ OBJCEKEventStore *eventStore = [[EKEventStore alloc] init]; EKEvent *event = [EKEvent eventWithEventStore:eventStore]; event.title = @&quot;EVENT TITLE&quot;; event.startDate = [[NSDate alloc] init]; event.endDate = [[NSDate alloc] initWithTimeInterval:600 sinceDate:event.startDate]; [event setCalendar:[eventStore defaultCalendarForNewEvents]]; NSError *err; [eventStore saveEvent:event span:EKSpanThisEvent error:&amp;err]; swiftlet store = EKEventStore() store.requestAccessToEntityType(.Event) {(granted, error) in if !granted { return } var event = EKEvent(eventStore: store) event.title = &quot;Event Title&quot; event.startDate = NSDate() //today event.endDate = event.startDate.dateByAddingTimeInterval(60*60) //1 hour long meeting event.calendar = store.defaultCalendarForNewEvents do { try store.saveEvent(event, span: .ThisEvent, commit: true) self.savedEventId = event.eventIdentifier } catch { // error } }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"Calendar","slug":"Calendar","permalink":"http://ios.taipei/tags/Calendar/"},{"name":"EventKit","slug":"EventKit","permalink":"http://ios.taipei/tags/EventKit/"}]},{"title":"String to Date, Date to String","slug":"DateToString","date":"2019-05-19T15:00:00.000Z","updated":"2019-10-12T07:04:38.415Z","comments":true,"path":"2019/05/19/DateToString/","link":"","permalink":"http://ios.taipei/2019/05/19/DateToString/","excerpt":"因為太常用了，所以存一份當紀念","text":"因為太常用了，所以存一份當紀念 import Foundation extension DateFormatter { convenience init (format: String) { self.init() dateFormat = format locale = Locale.current } } extension String { func toDate (dateFormatter: DateFormatter) -&gt; Date? { return dateFormatter.date(from: self) } func toDateString (dateFormatter: DateFormatter, outputFormat: String) -&gt; String? { guard let date = toDate(dateFormatter: dateFormatter) else { return nil } return DateFormatter(format: outputFormat).string(from: date) } } extension Date { func toString (dateFormatter: DateFormatter) -&gt; String? { return dateFormatter.string(from: self) } }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"Date","slug":"Date","permalink":"http://ios.taipei/tags/Date/"}]},{"title":"Delete in UITextField","slug":"textfieldDelete","date":"2019-01-02T15:00:00.000Z","updated":"2019-10-12T06:50:28.967Z","comments":true,"path":"2019/01/02/textfieldDelete/","link":"","permalink":"http://ios.taipei/2019/01/02/textfieldDelete/","excerpt":"Q: 在UITextField之中，要怎麼知道delete按下去了呢？這時候 我們可以透過delegate來判斷是不是刪除鍵按到了","text":"Q: 在UITextField之中，要怎麼知道delete按下去了呢？這時候 我們可以透過delegate來判斷是不是刪除鍵按到了 swiftimport UIKit protocol MyTextFieldDelegate { func textFieldDidDelete() } class MyTextField: UITextField { var myDelegate: MyTextFieldDelegate? override func deleteBackward() { super.deleteBackward() myDelegate?.textFieldDidDelete() } }實作 import UIKit class ViewController: UIViewController, MyTextFieldDelegate { override func viewDidLoad() { super.viewDidLoad() let input = MyTextField(frame: CGRect(x: 50, y: 50, width: 150, height: 40)) input.myDelegate = self view.addSubview(input) input.becomeFirstResponder() } func textFieldDidDelete() { print(&quot;delete&quot;) } }OBJC//MyTextField.h //create delegate protocol @protocol MyTextFieldDelegate &lt;NSObject&gt; @optional - (void)textFieldDidDelete; @end @interface MyTextField : UITextField&lt;UIKeyInput&gt; //create &quot;myDelegate&quot; @property (nonatomic, assign) id&lt;MyTextFieldDelegate&gt; myDelegate; @end //Implementation #import &quot;MyTextField.h&quot; @implementation MyTextField - (void)deleteBackward { [super deleteBackward]; if ([_myDelegate respondsToSelector:@selector(textFieldDidDelete)]){ [_myDelegate textFieldDidDelete]; } } @end實作 @interface ViewController : UIViewController &lt;MyTextFieldDelegate&gt; @end //View Controller Implementation - (void)viewDidLoad { MyTextField *input = [[MyTextField alloc] initWithFrame:CGRectMake(0, 0, 70, 30)]; input.myDelegate = self; [self.view addSubview:input]; } //MyTextField Delegate - (void)textFieldDidDelete { NSLog(@&quot;delete&quot;); }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"TextField","slug":"TextField","permalink":"http://ios.taipei/tags/TextField/"},{"name":"Delegate","slug":"Delegate","permalink":"http://ios.taipei/tags/Delegate/"}]},{"title":"iPlayground 2018 第一屆","slug":"iplayground2018","date":"2018-10-23T15:00:00.000Z","updated":"2019-10-13T04:27:36.995Z","comments":true,"path":"2018/10/23/iplayground2018/","link":"","permalink":"http://ios.taipei/2018/10/23/iplayground2018/","excerpt":"因為時間長度的關係，只能把各種不同的Test walkthrough 一遍 希望能激發與會者對於各種不同的測試有者不一樣的思維與想法 投影片","text":"因為時間長度的關係，只能把各種不同的Test walkthrough 一遍 希望能激發與會者對於各種不同的測試有者不一樣的思維與想法 投影片 https://github.com/ios-taipei/DataBed/raw/master/iPlayground.key","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"}]},{"title":"Other Tests","slug":"TestStory07","date":"2018-10-14T06:10:00.000Z","updated":"2018-10-20T03:05:23.047Z","comments":true,"path":"2018/10/14/TestStory07/","link":"","permalink":"http://ios.taipei/2018/10/14/TestStory07/","excerpt":"軟體開發故事07 - 其他不同的測試與驅動開發在整個軟體開發的過程中，還是會有一些可能要做的測試。 舉個例子 壓力測試","text":"軟體開發故事07 - 其他不同的測試與驅動開發在整個軟體開發的過程中，還是會有一些可能要做的測試。 舉個例子 壓力測試 有聽過server在做壓力測試的，為什麼手機APP也有機會要做壓力測試？ 舉個例子吧 以兩個帳戶之間互相轉帳為例子， a 有1000元 轉給 b 200元，b也同時轉200給 a，程式如下： 12345678910111213141516171819let a = Account(id: 1, balance: 1000)let b = Account(id: 2, balance: 0)DispatchQueue.global(qos: .background).async &#123; self.transfer(from: a, to: b, amount: 200)&#125;DispatchQueue.global(qos: .background).async &#123;self.transfer(from: b, to: a, amount: 200)&#125;func transfer(from: Account, to: Account, amount: Double) &#123; from.synchronized(self) &#123; () -&gt; Void in to.synchronized(self) &#123; () -&gt; Void in from.withdraw(amount: amount) to.deposit(amount: amount) &#125; &#125;&#125; 此時因為我們在背景執行轉帳時，就有可能發生Race condition或dead lock的情況發生，只做一次有可能是成功的，但是連續做個一萬次再來看兩個人的balance，一沒寫好，就有可能金額是不對的。 簡單的範例如下： 1234567extension NSObject &#123; func synchronized&lt;T&gt;(_ lock: AnyObject, _ closure: () throws -&gt; T) rethrows -&gt; T &#123; objc_sync_enter(lock) defer &#123; objc_sync_exit(lock) &#125; return try closure() &#125;&#125; 記憶體監控123override func didReceiveMemoryWarning() &#123; //這裡要測 &#125; 嗯，不多解釋了。 網路監控與測試 Network Link Conditioner Packet Logger Charles Proxy","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"Press Test","slug":"Press-Test","permalink":"http://ios.taipei/tags/Press-Test/"},{"name":"Monkey Test","slug":"Monkey-Test","permalink":"http://ios.taipei/tags/Monkey-Test/"}]},{"title":"What is QA","slug":"TestStory06","date":"2018-10-14T06:10:00.000Z","updated":"2018-10-20T03:05:30.400Z","comments":true,"path":"2018/10/14/TestStory06/","link":"","permalink":"http://ios.taipei/2018/10/14/TestStory06/","excerpt":"軟體開發故事06 - What is QA?從上述的故事之中，你會發現好像有人一直在滑手機或是不講話？那只是在這個故事之中特意的呈現。 什麼是QA? 在專案管理之中，QA是有明確的定義，Quality Assurance-品質保證工程師。","text":"軟體開發故事06 - What is QA?從上述的故事之中，你會發現好像有人一直在滑手機或是不講話？那只是在這個故事之中特意的呈現。 什麼是QA? 在專案管理之中，QA是有明確的定義，Quality Assurance-品質保證工程師。 為了避免和 QC (Quality Control)搞混，我們把專案執行的生命週期給畫出來，如此一來就知道角色的差異。 QA在執行的後期，做的工作其實是測試員 Tester 的工作如果知道明確的測試方式與工作，那麼由誰來做Tester，似乎就沒有那麼地強迫要非QA不可，有時候PM也跳下來測也不一定。 QA有多麼苦，我們可以看一下專案規模隨者時間演進的變化 圖表由左到右，藍色的部份代表這一期的功能產出，之後的藍色代表原專案的新功能（Change Requestment） 為了計算方便，假設每個區塊需要1個小時的測試時間，區塊與區塊間相依性的整合測試一樣也是需要一個小時的測試。 那麼，專案在第一期的測試時間為一個小時，專案在第二期的時候是3小時，專案在第三期的時候需要7小時，第四期的時候，要完整的測完，則是需要15小時。(有沒有很可怕？？) 不自動化，純手動測試，就會出現測試人員根本就來不及測試就上線的情況了。","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"QA","slug":"QA","permalink":"http://ios.taipei/tags/QA/"}]},{"title":"Unit Test","slug":"TestStory03","date":"2018-10-13T06:10:00.000Z","updated":"2018-10-20T03:05:54.648Z","comments":true,"path":"2018/10/13/TestStory03/","link":"","permalink":"http://ios.taipei/2018/10/13/TestStory03/","excerpt":"軟體開發故事03 - 單元測試 Unit Test 與 測試趨動開發 Test Driven Development (TDD)前情提要：工程師1有可能寫出一個功能，裡面的程式能通過測試用例，QA也沒測到，但是上線實測有可能會壞掉的嗎？","text":"軟體開發故事03 - 單元測試 Unit Test 與 測試趨動開發 Test Driven Development (TDD)前情提要：工程師1有可能寫出一個功能，裡面的程式能通過測試用例，QA也沒測到，但是上線實測有可能會壞掉的嗎？ 相信你應該有答案，那麼，為什麼要寫單元測試？因為公司要求，因為要被code review，因為要導CI、CD，因為別人bla bla bla…自己的想法呢？程式都沒時間寫了，不寫測試我可以多寫幾千行程式 大多時候工程師是一個不太好被別人說服的角色，那麼，我們來模擬一下工程師1怎麼使用SPE來同時寫出單元測試和實體程式 事前先準備好 單元測試所需要的環境 實際程式的環境 Ready, Go!!第一步，看一下我們的user story，先把測試給寫出來 123假設(Given)，存在有一個可用的帳號與密碼當(When)，使用者開啟APP,輸入帳號 aki ,密碼 qaz，點選「登入」然後(Then)，要看到首頁的內容。(success) test case 如下： 123456//============== Test ==================func testLoginSuccess() &#123; XCTAssert(login(acc: &quot;aki&quot;, pass: &quot;qaz&quot;)) &#125; 如上，我們寫出了第一個Test Case,此時試著跑一下Test,會得到 Test Failed，因為login函數還沒有實做。此時我們把Failed的狀態簡稱「紅燈」。 接著，我們需要把紅燈的地方修到好，所以要實作一個login函數，用以檢核帳號密碼，最終回傳成功或失敗 1234//============== Code ==================func login(acc:String,pass:String)-&gt;Bool&#123; return true&#125; 此時跑一下Test， 你會得到login回傳true，喔耶～～ 測試通過了，此時成功的狀態（success），我們簡稱為「綠燈」。 身為工程師的你，摸一下你的xx，不用多想也知道，不管什麼東西進來都是true，所以，我們白痴地依依 Test Case 來重構一下功能 12345678//============== Code ==================func login(acc:String,pass:String)-&gt;Bool&#123; if acc==&quot;&quot; || pass==&quot;&quot; &#123; return false &#125;else&#123; return true &#125; &#125; 白痴重構結束後，再跑一下測試，嗯嗯嗯 還是綠燈。那就可以拿下一個Test Case來做了 第二個使用者故事 如下 123假設(Given)，存在有一個可用的帳號與密碼當(When)，使用者開啟APP,輸入帳號 aki ,密碼 123，點選「登入」然後(Then)，要跳出錯誤訊息（Failed） 第二個Test case 如下： 寫測試123func testLoginFailed() &#123; XCTAssertFalse(login(acc: &quot;aki&quot;, pass: &quot;123&quot;)) &#125; 跑測試亮紅燈改code12345678910111213//============== Code ==================func login(acc:String,pass:String)-&gt;Bool&#123; if acc==&quot;aki&quot; &#123; if(pass==&quot;qaz&quot;)&#123; return true &#125;else if pass==&quot;123&quot;&#123; return false &#125; return false &#125;else&#123; return false &#125; &#125; 跑一下測試，綠燈重構，跑一下測試，綠燈1234567891011//============== Code ==================func login(acc:String,pass:String)-&gt;Bool&#123; if acc==&quot;aki&quot; &#123; if(pass==&quot;qaz&quot;)&#123; return true &#125; return false &#125;else&#123; return false &#125; &#125; 無限loop直到所有的測試都通過，此時程式就寫好了，而且應該被完整的重構過。 反思一下我們在上面的所有動作我們把上述的動作抽離出來 123Action 01: 寫好 Test Case 後,跑一下測試（嗯。。。紅燈）Action 02: 改code之後,跑一下測試（嗯。。。綠燈）Action 03: code的有沒有要重構或調整的部份，改完之後再跑一次測試，直到綠燈（重構） 在01－03之間，藉由不斷地添加Test Case，跑test case，寫程式，重構，來建構一個開發的流程。 這就是 TDD 呀！！ 想一下，不寫測試不行嗎？可以啊那有可能會發生什麼問題？QA會花很多力氣在做局部的測試，當一個專案愈大，就愈難完整的測到完，沒測試到的部份，頂多就是閉著眼睛上線，直接讓User幫你測試。這部份留到QA的部份再加以解釋 先寫代碼，再寫測試不行嗎？可以啊後來寫的測試可以證明這個代碼沒有bug，但是不能證明這個代碼能夠解決User使用上的問題 舉個例子吧。 我們想要寫一個function來知道一個字串是不是數字比如說 “123” 時為true，”ABC”時為false，於是工程師寫下了一段Code， 12345678func isInteger(aStr:String) -&gt; Bool&#123; do &#123; let a = try Int(aStr) return true &#125;catch &#123; return false &#125;&#125; 語意是利用變數型別的轉換正確或失敗來判斷這一個變數是不是數字 如果不做測試的話，其實是不會知道問題在那裡如果輸入了 “123” 為 true， 但是輸入了 “ABC” 一樣是true 12345678910func isInteger(aStr:String) -&gt; Bool&#123; let number = Int(aStr) if number != nil &#123; return true &#125; return false&#125; 兩個 Test Case “123”,”ABC” 的回傳都符合我們的預期。 在一般的情況下，也許上面的code沒有問題，但是如果今天也許我們需要經營辛巴威市場時，我們加個測試看會不會過 “1234567890123456789012345678901234567890”? 123func testIsTrue()&#123; XCTAssert(isInteger(aStr: &quot;1234567890123456789012345678901234567890&quot;))&#125; 再次強調，在很多情況之下，我們是很相信工程師的工程師有沒有可能出錯？ 那怕是千萬之一的機會，產品如果有問題，公司、團隊、個人能不能承擔犯錯之後的結果？工程師能不能信用擔保，或者用性命擔保程式沒有什麼？寫了測試就不會出錯了嗎？會，人還是會犯錯的，只是在一連串的犯錯的學習中，可以透過TestCase來了解，程式為什麼這樣子寫（有時候，別人也可以透過Test Case來了解程式的流程而不用深入程式實作的細節） 應不應該追求所謂的100％的測試覆蓋率(100 Test Coverage)？要看投入的時間成本，和所回收的效益，才能判斷值不值得。這個判斷的點，我們晚點回過頭來探討。 註1:如果你想要做TDD的練習，那麼有一些道場(dojo、どじょ)提供一些套路（Kata、型、かた），其中一個比較有名的道場如下：http://www.codingdojo.org/KataCatalogue/ 註2: 想一下： 有一段正則表示式是,你敢不敢直接把code推上production？ 1\\A(?=[a-z0-9@.!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]&#123;6,254&#125;\\z)(?=[a-z0-9.!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]&#123;1,64&#125;@)[a-z0-9!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[a-z0-9!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:(?=[a-z0-9-]&#123;1,63&#125;\\.)[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?=[a-z0-9-]&#123;1,63&#125;\\z)[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\z","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"http://ios.taipei/tags/Unit-Test/"}]},{"title":"UI Test, Record and Replay","slug":"TestStory04","date":"2018-10-13T06:10:00.000Z","updated":"2018-10-20T03:05:51.616Z","comments":true,"path":"2018/10/13/TestStory04/","link":"","permalink":"http://ios.taipei/2018/10/13/TestStory04/","excerpt":"軟體開發故事04 - UI Test ，操作行為的錄製與播放前情提要：工程師1把後端做好了 同時，另一位工程師2也把前端的UI也做好了，兩個前後端串接好後，直接交付由QA進行測試。 工程師2說：「前端不用測，QA會幫我們找到問題。」 如果你相信工程師2說的，那麼這章可以跳過不看。","text":"軟體開發故事04 - UI Test ，操作行為的錄製與播放前情提要：工程師1把後端做好了 同時，另一位工程師2也把前端的UI也做好了，兩個前後端串接好後，直接交付由QA進行測試。 工程師2說：「前端不用測，QA會幫我們找到問題。」 如果你相信工程師2說的，那麼這章可以跳過不看。 UI 要怎麼測？ 原始時代 － 佷久很久以前，工程師自己手按一按 漁獵時代 － 使用者來按或找有空的人一起幫忙按一下 農業時代 － 找專職的QA 來按 工業時代 － 用機器來測試程式 資訊時代 － 寫測試程式來測試程式A- I時代 － 用人工智慧來測試 前三個時代就不講了，第四個時代的開始，其目的在減少QA的負擔（人數） 怎麼用機器怎麼測試？機器能做什麼？？大量、重覆、一成不變的工作，是可以由機器所取代的。或許你用過XCode 內建的 Recorder 來錄製UITesting。很簡單，在按下錄製鈕後，操作app，就會自動產生一堆程式碼了。看你想要重構與否，基本上就算是ui test了 如果想要自己刻一個錄製機器呢？（為什麼待會會交代）目標：做一個Mac APP，將模擬器上的操作錄製下來，儲存結束，並且可以回覆播放 123451. 找到模擬器2. 紀錄滑鼠位置與動作3. 儲存結果4. 重覆播放5. 紀錄結果 開始吧 透過pid（process id）找到模擬器 1234567891011121314151617181920StopwatchStart();CFArrayRef windowList = CGWindowListCopyWindowInfo(listOptions, kCGNullWindowID);StopwatchEnd(&quot;Create Window List&quot;);// Copy the returned list, further pruned, to another list. This also adds some bookkeeping// information to the list as well as NSMutableArray * prunedWindowList = [NSMutableArray array]; self.windowListData = [[WindowListApplierData alloc] initWindowListData:prunedWindowList]; CFArrayApplyFunction(windowList, CFRangeMake(0, CFArrayGetCount(windowList)), &amp;WindowListApplierFunction, (__bridge void *)(self.windowListData));CFRelease(windowList); for (NSInteger i = prunedWindowList.count-1; i&gt;=0; i--) &#123; //iOS if([[[prunedWindowList objectAtIndex:i] objectForKey:@&quot;applicationName&quot;] containsString:@&quot;Simulator&quot;])&#123; &#125;else&#123; [prunedWindowList removeObjectAtIndex:i]; &#125; &#125; 其中 Application Name 是 Simulator， 如果你想用命令模式打開模擬器的話，可以用下面的指令玩看看 12345xcrun instruments -s //列出所有可用的的設備xcrun instruments -w &quot;iPhone XS (12.0)&quot; //開啟模擬器xcrun simctl install booted &lt;app路径&gt; //安裝ipaxcrun simctl launch booted &lt;app identifier&gt; //打開指定的appxcrun simctl uninstall booted &lt;app identifier&gt; //解除安裝 模擬器開啟後，記錄模擬器的座標、尺寸、滑鼠的座標與滑鼠的動作 一連串的紀錄允許簡單的編輯修改，定義為一個action存在資料庫，由許多action建構成一個 UI Test 將action用滑鼠事件回送到模擬器上，就可以重現QA的動作了 12345678//calculate new touch point x,yif(type==1)&#123; [mMouseEvent mouseTouchDownWithPoint: CGPointMake(ex, ey)];&#125;else if(type==2)&#123; [mMouseEvent mouseDragWithPoint: CGPointMake(ex, ey)];&#125;else if(type==3)&#123; [mMouseEvent mouseTouchUpWithPoint: CGPointMake(ex, ey)];&#125; 拍畫面用以比對結果 123456StopwatchStart();CGImageRef windowImage = CGWindowListCreateImage(imageBounds, singleWindowListOptions, windowID, imageOptions);Profile(windowImage);StopwatchEnd(&quot;Single Window&quot;);[self setOutputImage:windowImage];CGImageRelease(windowImage); 應用程式截圖 內建的很好用呀 為什麼不用內建的就好舉例來說 我們想要在同一個時間內跑多個裝置的ui test，或是ui test的test case太多，能不能夠分成兩組以上同時跑？ 也有時候座標記錄，相對來說，可利用性比較大一些。 比方說 IoT 寫字機 價值在那裡？聽話、任勞任怨比一個QA工程師的薪水便宜bla bla bla","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"UI Test","slug":"UI-Test","permalink":"http://ios.taipei/tags/UI-Test/"}]},{"title":"UI Test, Cucumberish","slug":"TestStory05","date":"2018-10-13T06:10:00.000Z","updated":"2018-10-20T03:05:36.703Z","comments":true,"path":"2018/10/13/TestStory05/","link":"","permalink":"http://ios.taipei/2018/10/13/TestStory05/","excerpt":"軟體開發故事05 - UI Test，Cucumberish工程師2 想要做 UI Testing, 又不想買機器的話呢？那麼就看看測試的資訊時代，用程式測試程式是怎麼做的？","text":"軟體開發故事05 - UI Test，Cucumberish工程師2 想要做 UI Testing, 又不想買機器的話呢？那麼就看看測試的資訊時代，用程式測試程式是怎麼做的？ 工具很多，只不過我選了 Cucumberish你也可以選別的，比方說 calabash，appium，macaca,…. 原因有機會再解釋。先來看一下 cucumberish吧 安裝 cucumberish 12345678910111213target &apos;TestMe&apos; do use_frameworks! target &apos;TestMeTests&apos; do inherit! :search_paths pod &apos;Cucumberish&apos; end target &apos;TestMeUITests&apos; do inherit! :search_paths endend pod install 完成後開啟 workspace 設定的部份請參考Github Cucumberish 主要有三個資料夾 Scenario(環境)、Steps(操作步驟)和Features(SPE文件) 完成後的檔案與資料夾(如圖) 在實作的一開始，工程師2拿到了一份 SPE 的 Feature 文件 1234567891011Feature: TestMe Cucumberish Login Test ExapmleScenario Outline: Verify Login ProcessGiven the app is runningWhen I enter Account &quot;&lt;acc&gt;&quot; and Password &quot;&lt;pass&gt;&quot;Then I should see &quot;&lt;result&gt;&quot;Examples:| acc | pass | result || aki | qaz | success || aki | 123 | 帳號密碼錯誤 | 接著到 Scenario 裡加上一個 LoginPage.swift 程式碼如下，大意是把操作的步驟給實作出來 Scenario 程式碼，以Login為例，Home的也要做 1234567891011121314151617181920212223242526272829303132333435363738import XCTestclass LoginPage: Page &#123; private lazy var account = findElement(.textField)[&quot;textAccount&quot;] private lazy var password = findElement(.secureTextField)[&quot;textPassword&quot;] private lazy var btnLogin = findElement(.button)[&quot;btnLogin&quot;] required init() &#123; waitFor(element: account) &#125; @discardableResult func checkPage() -&gt; LoginPage&#123; XCTAssertTrue(account.exists) XCTAssertTrue(password.exists) XCTAssertTrue(btnLogin.exists) return self &#125; @discardableResult func inputData(_ acc: String, _ pass:String) -&gt; LoginPage&#123; account.tap() account.typeText(acc) password.tap() password.typeText(pass) return self &#125; @discardableResult func clickLogin() -&gt;LoginPage&#123; btnLogin.tap() return self &#125; @discardableResult func clickAlert(_ msg:String) -&gt;LoginPage&#123; let msgResult = findElement(.alert).element.staticTexts.element(boundBy: 0).label XCTAssertEqual(msg,msgResult) return self &#125;&#125; 最後，Steps 把 Feature 的文件和 Scenario 裡的操作做結合 Steps 程式碼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import XCTestimport Cucumberishclass StepDefinetion: NSObject &#123; var application : XCUIApplication! func setup(_ application: XCUIApplication) &#123; self.application = application Given(&quot;the app is running&quot;) &#123; (args, userInfo) -&gt; Void in LoginPage().checkPage() &#125; When(&quot;I enter Account \\&quot;([^\\\\\\&quot;]*)\\&quot; and Password \\&quot;([^\\\\\\&quot;]*)\\&quot;&quot;)&#123;(args,userInfo)-&gt;Void in guard let acc = args?[0] , let pass = args?[1] else &#123; XCTAssert(false) return &#125; LoginPage().inputData(acc, pass) LoginPage().clickLogin() &#125; Then(&quot;I should see \\&quot;([^\\\\\\&quot;]*)\\&quot;&quot;)&#123;(args,userInfo)-&gt;Void in guard let expectedResult = args?[0] else &#123; XCTAssert(false) return &#125; if expectedResult == &quot;success&quot; &#123; HomePage().checkPage() &#125;else&#123; LoginPage().clickAlert(expectedResult) &#125; &#125; &#125; class func setup(_ application: XCUIApplication) &#123; StepDefinetion().setup(application) &#125;&#125; — 此次範例的 Github TestMe 在此— 跑一下 UITest 看看結果","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"UI Test","slug":"UI-Test","permalink":"http://ios.taipei/tags/UI-Test/"}]},{"title":"Specification By Example","slug":"TestStory02","date":"2018-10-13T06:00:00.000Z","updated":"2018-10-20T03:05:57.784Z","comments":true,"path":"2018/10/13/TestStory02/","link":"","permalink":"http://ios.taipei/2018/10/13/TestStory02/","excerpt":"軟體開發故事02 - 實例化需求 Specification by Example前情提要：在驗收的 D Day 當天，User發現了預期之外的驗證碼功能，覺得這項功能在手機上不需要，所以PM只好回過頭來，要求團隊再花時間把多做的功能拿掉。 請大家思考一下，那裡可能出現了問題？","text":"軟體開發故事02 - 實例化需求 Specification by Example前情提要：在驗收的 D Day 當天，User發現了預期之外的驗證碼功能，覺得這項功能在手機上不需要，所以PM只好回過頭來，要求團隊再花時間把多做的功能拿掉。 請大家思考一下，那裡可能出現了問題？ 不過是一個小小的使用者登入的功能，User心裡所想的，PM心裡所想的，工程師心裡所想的，QA心裡所想的，Art心裡所想的，都有可能不一樣？？？ 1990年，Elizabeth Newton － 史丹福大學心理學研究生，通過研究一個簡單的遊戲，提出了「知識的詛咒」（curse of knowledge）,在遊戲的過程中（註1），會因為每個人的背景不同，教育不同，經驗的不同產生出一種認知的偏差。 以故事之中APP登入的功能為例 User認為他對於登入的描述夠清楚了。 PM知道其他APP是怎麼登入的而User提出的需求沒有太特別，一定做得出來。 工程師1想的是APP其他型態的登入要不要做 工程師2在意的是資料欄位的檢核，也許還要先開規格給工程師1 Art只能憑過去的經驗，把猜測要出的圖出一出 QA還沒進入狀況，等開發出來之後再來看 通常，一個團隊裡面，大多數會存在一個意見領袖，抑或是一個脾氣很大的人，或是比較強勢不讓步的人，這裡分別用工程師2的角色代入這個情境來看看。 PM: 老闆說不要放驗證碼 工程師2：APP不加驗證碼的話，不就等於裸體上街一樣嗎，駭客知道你的API後一直打，後台掛掉你要負責嗎？ 工程師1：沒有人在APP上放驗證碼的。 Art: （小聲）UX的確不放驗證碼比較好。 QA: 你們決定好就好。 （幾個循環之後） 工程師2：請尊重專業好嗎？資安你不懂啦，每個使用者登入都要檢核，放驗證碼是最簡單最基本的。(怒氣值＋10) 工程師2：舊專案的網頁有放驗證碼，後端的檢核機制是一樣的，你要給我2倍的時間把程式拉出來另外寫，當初你沒有說，所以估時間沒算到要加寫的時間。(怒氣值＋10) 工程師2：我有其他更重要的ticket，你要把一些ticket拿掉，這個當初是你沒有講清楚的，我不想加班幫你擦屁股。(怒氣值＋10)（幾個循環又幾個循環之後） 工程師2：改好了。 工程師1(心想):舊的code先不砍好了，我有預感會加回來。 Art: 工程師1知道怎麼弄吧，自己砍就好了，設計沒有變，不用問我。 QA（心想):終於…. （此時生產線才開始活絡了起來，工程師1才開接後台，好了之後套圖，把之前的元件delete掉，好了QA才開始點個幾下，馬上交付給PM） 於是乎。User過了幾天後才拿到拿掉驗證碼的版本。 Scenario 檢討會議 工程師1: PM 你要問清楚，需求不明確的話下面的人很難做事 工程師2: PM 每次都把問題丟到團隊裡，事後再來說這裡不對、那裡不對 Art: （轉筆+發呆） QA: 不要只會說 PM, 配合 PM 本來就是職責 PM: (怒氣+100) Scenario 老闆辦公室 PM: 老闆下次可不可以多講一些？ User: 我是老闆還是你是老闆？ 故事從這裡再停一停。反思一下上述已經發生的問題。 你看到了那些問題？ 你覺得這個團隊的氣氛如何？是開心？還是很有凝聚力？如果BDD、ATDD可行的話，為什麼還有這麼多問題呢？有什麼方法可以讓這個團隊可以做出符合使用者期望的功能呢？ 實例化需求 Specification by Example我們來回顧一下團隊的需求金字塔 User: 我說的算 PM: 準時或提早做出符合使用者期望的功能 Art: 不要違背UX和美感 QA: 做出來的東西要能夠測試 工程師2：在乎的是資料格式，檢核，串接、資安、系統穩定 工程師1：需要知道要的的範圍邊界，登入的方法很多，有無窮多種可能性的登入方法，比方說Facebook Login,指紋登入，人臉辨識登入。 需求愈往下，就愈發散，創造各式各樣的可能性就愈多。 看起來，要讓需求不發散，避免各說各話，甚至是可以聚焦的一份好的規格文件。 然後，我們來看看這份好的文件要有那些優點？ 大家都看得懂（廢話） 大家看完之後不會衍生出一堆黑人問號 對要製做的功能與文件的描述能要夠相符，User也可以買單 有人問我，為什麼PM寫的專案需求文件沒有人看？裡面有scope time cost，quality… 想要找什麼，裡面都有寫了呀？(理論上是醬子沒錯)實際上，很少有人會去看專案文件，這在軟體業裡算是常態吧，大多數軟體開發細節，或是User Story，很少會落在白紙黑字之上，通常文件寫好之後就束諸高閣，無人問津，最後連更新文件都變得是件苦差事。 一份沒有人看的文件，那怕製作再精美，多麼圖文並荿，也是沒有價值的廢紙。 那，有什麼好的建議呢？「舉個例子吧」 OS:什麼？ 什麼意思？ 你說的是「舉個例子」？ 那你舉個例子來看看 我們回到第一次的場景 Scenario 01: 地點－老闆辦公室 User： 幫我們的APP做一個登入的功能，當使用者登入後要看到首頁的內容。 PM: 好，我請團隊評估一下所需要的時間。應該一個星期可以完成。 可以舉個例子嗎？ User： (吱吱喳喳…) PM： (吱吱喳喳…) PM：我整理一下，討論的結果是不是如下： 我用帳號 “aki” 密碼 “qaz” 按「登入」鈕之後，畫面會移轉到「首頁」 我用帳號 “aki” 密碼 “123” 按「登入」鈕之後，登入失敗，會跳出「帳號密碼錯誤」錯誤訊息 為了方便，我們將它整理成一份表格 1234As an User,I Want a login feature.When I enter @account and @password,So That I Can see Main Page. account password result aki qaz success aki 123 帳號密碼錯誤 Scenario 02: 地點－團隊會議室 工程師1：我想加兩條，沒有輸入帳號，或是沒有輸入密碼的都算是錯誤 account password result aki 帳號密碼錯誤 qaz 帳號密碼錯誤 工程師2：我想加個兩條，帳號有最短和最長的限制，太短或太長都不能讓使用者打我的api account password result ak qaz 帳號長度不符 DaijyoujitaniSaemonzaburo qaz 帳號長度不符 團隊: (吱吱喳喳…) PM: 我們統整一下表格如下： account password result aki qaz success aki 123 帳號密碼錯誤 aki 密碼不得為空 qaz 帳號不得為空 ak qaz 帳號長度不符 DaijyoujitaniSaemonzaburo qaz 帳號長度不符 （註2） QA: 咦，Test Case竟然順便寫好了，那我可以用自動化工具來寫測試了(暗爽中) Art: 只要三個元素呀，兩個輸入框，一個登入鈕，我就先出這幾個元素的圖 PM: 大家看一看沒問題的話，我就拿這一張表格再去和User再確認一次 從上面的表格中我們觀察到「有什麼」？? 資料庫裡真的有一個帳號 aki ，密碼為 qaz 帳密未輸入的防呆有了 帳號基本的長度檢核有了 從上面的表格中我們觀察到「沒有什麼」？? 沒有驗證碼(當PM拿著例子去和User確認時就會知道了) 密碼強度？ 一般常見的強規則是：密碼最低要求8字元; 必須包含至少一個大寫英文字元，至少一個小寫英文字元，至少一個數字字元，至少一個符號字元自己試著練習一下，加上一條密碼強度檢核條件，也要順便檢查輸入的值和輸出的結果有沒有需要調整的 反思一下，這個團隊做了什麼樣子的改變？?當有人為了這個流程舉了一個例子之後，所有的人都可以用這個例子放到自己心目中的流程去試一下，有什麼不對的地方，一旦發現了，再多加幾個例子來描述這個流程有什麼不足的地方，例子愈多，流程就愈完整，就愈不容易做出預期之外的功能了 什麼樣的例子是好的例子？ 愈真實的例子愈好 愈簡單愈好 舉個例子 account password result test test success 工程師2拿出自己的測試資料當例子時，有沒有可能會測試通過，但是換個帳號就測試失敗了？有沒有可能有個通用密碼為test，不管什麼帳號用test當密碼都能登入。 拿真實的帳號來測，問題就自動消失了 舉第二個例子 account password result aki qaz success DaijyoujitaniSaemonzaburo qaz 帳號長度不符 DaijyoujitaniSaemonzabur qaz success 帳號的長度少一個字元後就成功了在邏輯上，這兩條指的是相同的一件事，就是帳號長度存在一個邊界，且邊界值為24, 第三條就顯得多餘了。 當然，你想要多加幾條測試來增加信心，也不是不行，但是生命就應該花時間在更有價值的事情上不是嗎？ 註1：遊戲有兩個角色，一個人是敲節奏的人（A），一個人是聽到節奏猜歌曲的人(B)。實驗如下：選定120首歌曲眾所能詳的歌曲，由A敲節奏，由B聽節奏猜歌曲，分別予以紀錄。按照伊莉莎白根據實驗得出的結果:A認為自己敲的節奏能夠讓B猜出來的機率為50%B聽到A敲打的節奏而正確猜到歌曲的機為只有2.5% 註2：大正寺谷 左衛門三郎","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"SPE","slug":"SPE","permalink":"http://ios.taipei/tags/SPE/"}]},{"title":"Software Development Story 01 - User Story, ATDD and BDD","slug":"TestStory01","date":"2018-10-13T06:00:00.000Z","updated":"2018-10-20T03:06:03.480Z","comments":true,"path":"2018/10/13/TestStory01/","link":"","permalink":"http://ios.taipei/2018/10/13/TestStory01/","excerpt":"軟體開發故事01 - 使用者故事 User Story, 驗收測試動開發 ATDD -Acceptance Test Driven 與 行為驅動開發 BDD - Behavior Driven Design很久很久以前，軟體開發的形狀是醬子的 在大多數軟體開發的歷程中，當老闆藉由市場資訊以及用戶需求，口述軟體想要什麼樣子的操作，希望得到什麼樣子的結果，甚至對於軟體的細節，像是用辭字句，甚至是顏色等等。 於是，使用者和工程師之間，就會不斷地在開發與驗收的過程中產生溝通的問題。","text":"軟體開發故事01 - 使用者故事 User Story, 驗收測試動開發 ATDD -Acceptance Test Driven 與 行為驅動開發 BDD - Behavior Driven Design很久很久以前，軟體開發的形狀是醬子的 在大多數軟體開發的歷程中，當老闆藉由市場資訊以及用戶需求，口述軟體想要什麼樣子的操作，希望得到什麼樣子的結果，甚至對於軟體的細節，像是用辭字句，甚至是顏色等等。 於是，使用者和工程師之間，就會不斷地在開發與驗收的過程中產生溝通的問題。 為了解決使用者與工程師之間溝通(雞同鴨講）的問題，於是乎創造出一個職位叫做PM，擔任團隊的溝通窗口，建立一道防火牆，避免老闆因為專業度的不足，做出難以達成的目標，軟體成果無法交付，或是對於團隊直接指導棋，造成團隊向心力潰散。 PM 在做什麼？PM的出現是來解決問題的，為了向老闆報告，於是工作開始細分成一包包的工作包，介定要作的範圍、時間以及要花的成本，避免品質落差太大，所以要做品管，對內要做好團隊成員的團隊建立，團隊溝通的方式，管理風險，以及外包、採購的管理。最重要的任何一個可能會影響專案成敗的利害關係人都必須打點好，專案才有可能順利結案，老闆才能拿到如專案計劃所規劃的產出（軟體）。 PM 最重要的是什麼？：如果PM不懂技術，就會再長出一個System Analysis或是System Architecture的角色,如果PM不懂營運，就會再長出一個Business Analysis的角色，如果專案太大，就會再長出一些小PM，將專案分切成許多小專案。如果專案成本金額太高，財會部門會來幫忙，如果PM不懂時程規劃，就會再長出一個跟催(Expeditor)的角色，PM不懂品質管制，就會長出QA和QC，如果PM不懂任用人事，就會有Functional Manager或HR介入，如果PM不懂工具，MIS會來幫忙，如果PM不懂外包，就會由採購來介入。 一個團隊之所以變得如此偉大（真的要搞到這麼大？？），由此可見PM的重要性！！！ 一個PM就要練就各式各樣的溝通模式（簡稱：見人說人話）身為一個團隊的窗口，能夠做到將老闆的表達，清楚地轉化為團隊不同成員之間可以正確理解的話語、文件或是其他形式的紀綠。管理團隊成員能夠在時程之內交付產出。 故事從這裡先停一停。反思一下可能存在的問題。 要怎麼訓練大家有相同的溝通方式和基礎呢？？舉個團隊日常的故事當例子吧 出場角色表 職責說明 User 軟體所有權有者 PM 出張嘴的防火牆 軟體工程師1 前端開發者 軟體工程師2 後端開發者 Art UI/UX，出圖都靠他 QA 替User做早期驗收，對程式測試有足夠的了解，避免交付出太糟糕或是問題一堆的軟體，有時候沒有這個角色，大多是不進行測試，責任對內由工程師扛，對外由PM扛 用戶 市場上真正的軟體操作者 Day 1Scenario 01: 地點－老闆辦公室 User： 幫我們的APP做一個登入的功能，當使用者登入後要看到首頁的內容。 PM: 好，我請團隊評估一下所需要的時間。應該一個星期可以完成。 Scenario 02: 地點－團隊會議室 PM: 老闆說APP要一個登入的功能，使用者登入後要看到首頁的內容。（90％老闆的表達原文轉錄） 工程師1: 只要登入就好？要不要Facebook Login? 要有人上去fb後台設定後，我才能串接哦 工程師2: 要開那些欄位？長度多少？ API那記錄那些東西？不要不自動登入？OAuth咧？JWT? Art: 是不是給底圖和色碼就好了？ QA: 等你們做完我再測（繼續滑手機） !@#$%^&amp;!@#$%^&amp; 七嘴八舌分隔線 !@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp; 七嘴八舌分隔線 !@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp; 七嘴八舌分隔線 !@#$%^&amp;!@#$%^&amp;!@#$%^&amp;!@#$%^&amp; PM: 我再去和 User 確定好了 一天過去了，一天過去了，一天過去了，一天過去了 (除了PM之外，團隊都沒在忙) Day 2 PM: User說登入用帳號＋密碼，想要早點拿到，Facebook登入要不要做都可以，自動登入如果有的話是最好的了。User 不懂什麼是OAuth，什麼是JWT，你要用簡單的話說，不然我也不知道怎麼和User解釋 工程師2: 不懂不要做最好了，那帳號欄位長度多少？密碼強度呢？怎麼沒問呢？ PM: User才不懂那些東西，你照上次專案怎麼做就copy一份來接著做。 工程師1: 我畫面拉好了，等著後端做好之後，我再來串。以防萬一，我把JWT的code貼一份到程式裡放著，要用的話馬上就有了。（自信滿滿） Art: (好像沒人理我，我自己出個RWD設計好了，以免被人說我沒做事) QA: 等你們做完我再測（繼續滑手機） Day (D-1）早上 PM: QA東西測了沒？ 明天要交 QA: 東西還沒給我測試，誰知道他們在慢什麼，太晚給我，我又要加班測了，喂!PM,我要登記申請今天的加班。 工程師2: 我也要，如果QA測有問題的話，我也要加班來改。 工程師1: 避免你們改了什麼，要害我修改APP，原本要去約會的，只好改天了。 Art: 大家都加班了，我也加班stand by好了。 PM: ..!@#$%^&amp;!@#$%^&amp;….. Day (D-1）晚上 QA: (測試中) 工程師1: (看ptt) 工程師2:（看youtube） Art: （看pinterest） QA: 這裡好像怪怪的，為什麼帳號輸入特殊符號也可以登入，你們在寫程式的時候自己都不測的嗎？ 工程師1: 後端要擋一下呀！ 工程師2: 前端為什麼不擋？ (各自念個兩句後，就開程式起來改了) QA: (繼讀測試) 工程師1: (看ptt) 工程師2:（看facebook） Art: （看Dcard） PM: （好了沒？） 幾個循環之後，功能完善了，QA也驗完了 PM: 大家這麼努力為工作付出，有這麼好的團隊真的太幸福了。大家可以下班了。 眾人: （眼神死）很多東西一開始就講好，如果夠清楚的話，也不用最後再來一直改…. Day DScenario 01: 地點－老闆辦公室 User: 這..做出來的東西好像和我們一開始說的不一樣…怎麼多了一個驗證碼？ PM: 我會開一張ticket，請團隊拿掉。 Scenario 02: 地點－團隊會議室 PM: 是誰自動主張把驗證碼加上去的？ 工程師2: 我們的網頁專案一直都有驗證碼的功能… 工程師1: (JWT的code這次沒用到，躺著裡面不會被發現吧) ART: (iPad不用測呀？我有做，不過好像沒什麼人關心) 從上面的故事中我們觀察到了什麼？? 溝通很重要 每個人都覺得自己是個很好溝通的人（尤其是PM） 當下說好的東西不一定照著做，可能會受到以往的經驗而做出自己的判斷 當然，或許你有其他的觀察，我們留到後面再說。 你對於這個團隊的感覺是什麼？ 還算可以的團隊，至少東西有做出來了 好像還可以更好？ 思考一下，對於這個團隊最有幫助的可能是什麼？ 有效的溝通 與User確認過的，一份大家都看得懂的好的規格書 什麼是使用者故事 User Story?回顧一下軟體開發的第一天 User說的話 「幫我們的APP做一個登入的功能，當使用者登入後要看到首頁的內容。」這句話，其實就是一個典型的User Story。 我們稍微改一下描述。 1234As an User,I Want a login feature.When I login,So That I Can see Main Page. 對於User來說，完整地說出一個故事，就已經是相當盡責的User了。接著呢？PM和團隊要設法將一個個的故事拆解，變成許多工程師可以實作的功能，並且可以滿足故事的測試用例。好讓QA可以測試，一同做出使用者可以驗收的產品。 由User Story 衍生出的 ATDD、BDD拆解成可測試用例的動作就是所謂的ATDD, Acceptance Test Driven Design 關注於使用者的操作行為所需要的功能拆解就是所謂的BDD, Behavior Driven Design。 以下介紹 Gherkin 語法，用自然語言來定義與描述測試用例 123456Feature:在APP實現一個登入的功能Scenario:假設(Given)，存在有一個可用的帳號與密碼當(When)，使用者開啟APP,輸入帳號,密碼，點選「登入」然後(Then)，要看到首頁的內容。 如此一來，我們就能夠將一個個的使用者故事，轉化成一個個可以讓大家容易理解的測試用例，工程師知道怎麼做，QA知道怎麼驗，使用者在驗收時就一定會買單了。 （美美的畫面如何測試與驗收，留到UI Testing時再來說，一般而言，一定也可以用Gherkin語法來闡述有關UI/UX的測試用例） （後話）：Gherkin語法和企管學裡的 STAR 非常地像，在大公司裡，或多或少都會用STAR語法來寫HR最喜歡的績效評量(Performance Appraisal)或是在面試時用STAR來檢驗應徵者的描述是否完整。S: Situation, T:Task, A:Action, R:Result 那麼要如何正確地寫出好的Acceptance Test Cases?要怎麼樣做會更好？？ &lt;未完待續&gt;","categories":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://ios.taipei/tags/Test/"},{"name":"User Story","slug":"User-Story","permalink":"http://ios.taipei/tags/User-Story/"},{"name":"ATDD","slug":"ATDD","permalink":"http://ios.taipei/tags/ATDD/"},{"name":"BDD","slug":"BDD","permalink":"http://ios.taipei/tags/BDD/"}]},{"title":"DUNS申請以及相關問題","slug":"duns","date":"2018-06-24T15:00:00.000Z","updated":"2018-06-25T14:00:53.913Z","comments":true,"path":"2018/06/24/duns/","link":"","permalink":"http://ios.taipei/2018/06/24/duns/","excerpt":"D-U-N-S 申請以及相關問題Q: What is D-U-N-S?","text":"D-U-N-S 申請以及相關問題Q: What is D-U-N-S? A: The D‑U‑N‑S Number is a unique nine-digit identifier for businesses. It is used to establish a D&amp;B® business credit file, which is often referenced by lenders and potential business partners to help predict the reliability and/or financial stability of the company in question. “D‑U‑N‑S,” which stands for data universal numbering system, is used to maintain up-to-date and timely information on more than 300 million global businesses. 大意是說，有跨國生意需求時，可以幫你做基本的徵信，以降低風險。 不知為何，被APPLE拿來當做公司帳號的初步篩選。因此，如果想要申請公司或組織的開發者計劃，或是企業方案之前，都要先有一組D-U-N-S號碼，才能夠繼續進行。 通常在台灣，如果是成立一段時間的公司，會由台灣鄧白氏主動幫你加入，申請之前，可以先查一下，看有沒有已經有號碼了 點我 查詢 D-U-N-S Legal entity name （公司組織法律名稱） Headquarters address (總公司地址) Mailing address (郵件位址) Your work contact information (聯絡方式) 如果沒有的話，就必須要申請 D-U-N-S 了，一樣的流程，只是時間會久一點（據說要五個工作天，建議是多留點時間等等），這裡會由D&amp;B的真人來電話聯絡，用以確認是否為正常的公司。 有可能被reject的事項為 獨資的個人公司 無法查到公司正確的相關資訊 DBAs - Do Business As XXX (e.g. iOS@Taipei 不是一個合法的公司名稱) Fictitious Name - 虛擬名稱 貿易名 分公司名 （需由總公司統一申請） 這裡會用真人打電話聯絡確認，回答如果不正確的話，可是會被reject的","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"教學","slug":"教學","permalink":"http://ios.taipei/tags/教學/"}]},{"title":"寫在程式開發之前00-1","slug":"Tutorial_00_1","date":"2018-06-24T15:00:00.000Z","updated":"2018-06-25T14:01:03.369Z","comments":true,"path":"2018/06/24/Tutorial_00_1/","link":"","permalink":"http://ios.taipei/2018/06/24/Tutorial_00_1/","excerpt":"寫在程式開發之前 00-1Q: 什麼是 Apple ID? 什麼又是 Developer Program?","text":"寫在程式開發之前 00-1Q: 什麼是 Apple ID? 什麼又是 Developer Program? A: 假設你使用過apple的任一個電子設備，並且註冊過帳號，那麼這個帳號則稱為 Apple ID 假設你使用Apple ID登入開發者登入 進行操作, 若你未入加入任何一個開發者計劃，會被提示 Enroll in iOS Developer Program 若你已加入，則會顯示 Individual 和 Company/Organization 兩種不同的類型 (需支付一年$99USD的費用)，此時就可以進行後台的使用，如憑證、裝置管理、APP管理等功能，同時 itunes connect 也可以針對上架的APP進行管理 獨立個人開發者 (Individual) 可以單人使用，但是無法加入第二個、第三個開發者共同開發，如果有共同協作開發需求時，只能將自身的憑證與相關檔案交付給其他人才能同步開發，或是在xcode的偏好設定中，輸入帳號密碼給第三者。 公司、組織 (Company/Organization) 則是可以加入多人共同開發，如果有人員異動時，也方便由帳號管理中加入或移除，而非由單一帳密或憑證檔案管理的方式。 要申請為公司類別，需要 DUNS 鄧白氏號碼，若只為了apple 開發申請的話，可以加入免費版本。如何申請 DUNS，會由另一篇文章來解釋。 若有企業開發需求（B2B），或是 ( 無法 ) 不想在app store上架等等，可以申請 Enterprise Program (＄299 USD/年), 申請方式和公司類別相同，但是申請審查會更加地嚴格。申請流程會用另一篇文章來解說。 附註：Apple ID 若為Enterprise Program的話，是不能和其他 developer program混用的，在此同時，itunes connect 也會變成無法登入的狀態 最後，如果想要開發apple的配件的話，則是要啟用 MFi Program，繳的費用和上面都不一樣，這又是另一篇故事了。 Q: 什麼是 Team ID ? 什麼是 App ID ? 什麼是 Bundle ID? 什麼是 Product ID ? A: Product ID 指的是在app store裡，用來區分不同的APP之間的差異。一些功能，如推播，就是依賴Product ID來找到你的APP，好將訊息正確送到你的手機上。Product ID是由 Team ID + Bundle ID所組成的 Team ID是在加入開發者計劃後，由系統給予的一組文字，你可以在開發者網站 &gt; 會員（membership）裡找到這個值。(未來如果想要推播的話，這個值就會派得上用場了) App ID 通常會使用域名反解(reverse domain name)的規則以避免和其他人重複，未來上架時無法新增APP。 App ID 在 XCode裡又稱之為 Bundle Identifier，也有人寫成 Bundle ID， Q: 什麼是 UUID ? 什麼是 advertisingIdentifier ? A: UDID (Unique Device Identifier) 指的是iOS設備上唯一的裝置識別標籤 - 和 UUID 不同 Universally Unique Identifier） 附註：APP刪除再重裝的時候，UDID據說是會改變的，通常會寫入一份在手機的keychain裡，在做一些統計的時候派得上。 advertisingIdentifier是另一個辨別裝置的標籤，由AdSupport.Framework提供，如果沒有使用到廣告但是加入了advertisingIdentifier的呼叫的話，可是會被退件的 自已產？！！！吃飽太閒的話，也可以啦！！ 在 itunes 桌面應用程式裡，接上手機並且信任之後，可以在手機的摘要裡找到 UDID XCode裡的裝置，摘要裡也找得到。 當然，也可以下載一些來路不明的描述檔加以信任，並且連到特殊的網站後，可以查得到UDID","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"教學","slug":"教學","permalink":"http://ios.taipei/tags/教學/"}]},{"title":"Carthage-introduction","slug":"Carthage-introduction","date":"2018-06-21T15:32:12.000Z","updated":"2018-06-21T15:34:31.000Z","comments":true,"path":"2018/06/21/Carthage-introduction/","link":"","permalink":"http://ios.taipei/2018/06/21/Carthage-introduction/","excerpt":"相信大家對於CocoaPods非常的熟悉，用的愛不釋手，那麼為什麼還要看一下Carthage呢？","text":"相信大家對於CocoaPods非常的熟悉，用的愛不釋手，那麼為什麼還要看一下Carthage呢？ 在還沒有CocoaPods之類，大家都是用拖檔案，拖library進來，甚至是拖另一個專案到專案裡面來，記得還要copy items if needed，有CocoaPods，只要幾行指令，就完成了所有的工作了，就連考試都得了一百分呢！！ Carthage與CocoaPods的不同在那裡呢？ 首先，CocoaPods預設會自動產生具有dependency的workspace並且更新你的專案檔，Carthage則是使用xcodebuild來打包成framework，以方便引用，避免污染專案檔 再來，CocoaPods在每次編譯時，都會重新打包所有的pods，當使用第三方元件使用的多時，編譯就會變慢，有機會會差到幾十秒 最後，Carthage比CocoaPods好封裝多了，只要開一個Project/Framework,裡面的scheme設為shared就可以了 附帶一提的是 Carthage 的打包，可以不讓別人看到source code，這不知道要算優點還是缺點 1。安裝Carthage Carthage提供OS X平台的pkg安裝文件，可以從Github的最新release中找到，按照指示一步步安裝即可。 2。新增framework到程式裡 安裝完Carthage後，你能够使用它来新增framework到你的專案裡。注意Carthage只支持dynamic framework(iOS8以上)。 3。執行 1carthage update 和CocoaPods一樣，會將相依的資料抓到 Carthage/Checkouts 目錄下，並且編譯好 4。設定在你的專案的target的[General][Embedded Binaries]，將framework從Carthage.build裡拉進去。（如果有git，也順便push上去，醬子其他人只要執行carthage bootstrap就能使用了。 5。update如果變動了Cartfile，或者想升级到最新版本，執行carthage update命令就可以了。 6。檢查如果編譯失敗的話，試著在命令列執行 1xcodebuild -scheme SCHEME -workspace WORKSPACE build 或 1xcodebuild -scheme SCHEME -project PROJECT build 其中大寫的地方要換成你的workspace或專案名稱, 有沒有很簡單？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"Dependency Management","slug":"Dependency-Management","permalink":"http://ios.taipei/tags/Dependency-Management/"}]},{"title":"GCD","slug":"GCD","date":"2018-06-21T15:08:55.000Z","updated":"2018-06-21T15:12:08.000Z","comments":true,"path":"2018/06/21/GCD/","link":"","permalink":"http://ios.taipei/2018/06/21/GCD/","excerpt":"GCD 有許多用法，不知道你會那幾種？","text":"GCD 有許多用法，不知道你會那幾種？ 1. 背景執行 12345678let defaultPriority = DISPATCH_QUEUE_PRIORITY_DEFAULTlet backgroundQueue = dispatch_get_global_queue(defaultPriority, 0)dispatch_async(backgroundQueue, &#123; let result = doSomeExpensiveWork() dispatch_async(dispatch_get_main_queue(), &#123; //use `result` somehow &#125;)&#125;) 2. Singleton 12345678+ (instancetype) sharedInstance &#123; static dispatch_once_t onceToken; static id sharedInstance; dispatch_once(&amp;amp;amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 3. with blocks 12345678910111213141516typealias DoneBlock = () -&amp;gt; ()typealias WorkBlock = (DoneBlock) -&amp;gt; ()class AsyncSerialWorker &#123; private let serialQueue = dispatch_queue_create(\"ios.taipei.queue\", DISPATCH_QUEUE_SERIAL) func enqueueWork(work: WorkBlock) &#123; dispatch_async(serialQueue) &#123; let semaphore = dispatch_semaphore_create(0) work(&#123; dispatch_semaphore_signal(semaphore) &#125;) dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) &#125; &#125;&#125; 4. multi-task 123456789dispatch_group_t group = dispatch_group_create() for item in someArray &#123; dispatch_group_async(group, backgroundQueue, &#123; performExpensiveWork(item: item) &#125;) &#125; dispatch_group_notify(group, dispatch_get_main_queue(), &#123; // all the work is complete&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"http://ios.taipei/tags/GCD/"}]},{"title":"XCode 搜尋小技巧","slug":"xcode-search","date":"2018-06-21T15:00:28.000Z","updated":"2018-06-21T15:22:15.000Z","comments":true,"path":"2018/06/21/xcode-search/","link":"","permalink":"http://ios.taipei/2018/06/21/xcode-search/","excerpt":"茫茫碼海中，要怎麼找到你想要找的那一段程式碼？關鍵字下的不夠精準，找不到或是搜尋的資料太多，都是種苦惱。還是想找個Hex? 找Tab? 找ip？ 找url？ 找email? 好的搜尋技巧帶你上天堂，下面幾個技巧該可以能帶你上天堂","text":"茫茫碼海中，要怎麼找到你想要找的那一段程式碼？關鍵字下的不夠精準，找不到或是搜尋的資料太多，都是種苦惱。還是想找個Hex? 找Tab? 找ip？ 找url？ 找email? 好的搜尋技巧帶你上天堂，下面幾個技巧該可以能帶你上天堂 定義搜尋（只搜尋「定義」的字串） 搜尋關鍵字會把所有找到的資料帶出來（以simple為例） 在find的第二層，將搜尋改為definition 結果就只會出現「定義」裡的關鍵字搜尋了 &nbsp; 2. Pattern 在搜尋裡先打一個「”」,用以區隔 pattern之用，接著，在放大鏡裡點選 insert pattern 接著，點選「url」,再補個「”」給他 結果，就是我們想要的結果 3. 指定路徑 如果是已知路徑下搜尋，只要在 下方的「in Workspace」點一下 再點選你要搜尋的路徑就可以了 有興趣的人還有scope的進階版可以玩 Call Hierarchy 想知道有誰呼叫了某個函數？ 還有一個方法，就是當你移到函數的位置時","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"xCode","slug":"xCode","permalink":"http://ios.taipei/tags/xCode/"}]},{"title":"SpotLight 初探","slug":"Spotlight-inspect","date":"2018-06-21T15:00:28.000Z","updated":"2019-10-12T14:38:55.798Z","comments":true,"path":"2018/06/21/Spotlight-inspect/","link":"","permalink":"http://ios.taipei/2018/06/21/Spotlight-inspect/","excerpt":"當使用者使用spotlight查詢時，總是有些app會列出內容出來，那又是怎麼樣的小技巧呢？","text":"當使用者使用spotlight查詢時，總是有些app會列出內容出來，那又是怎麼樣的小技巧呢？ 先把兩個必要的framework包進來 import CoreSpotlight import MobileCoreServices 接著，準備一個獨立的ID，避免與別的app衝突，通常會使用域名反解，與一個資料陣列,型別為 CSSearchableItem 12let domainID: String = \"com.yuaki.informationPlus\"var searchableItems: [CSSearchableItem] = [] 接著， 定義每筆資料的屬性設定 (item為資料物件) 12345let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeItem as String)attributeSet.title = item.titleattributeSet.contentDescription = item.subtitleattributeSet.contentCreationDate = item.date 接著為這個屬性設定關鍵字,以方便被搜尋 1234// define search keywordsvar keywords = item.title.componentsSeparatedByString(\" \")keywords.appendContentsOf(item.subtitle.componentsSeparatedByString(\" \"))attributeSet.keywords = keywords 然後把屬性放到 CSSearchableItem裡 再加到陣列中備用 let searchItem = CSSearchableItem(uniqueIdentifier: \"Parking\", domainIdentifier: domainID, attributeSet: attributeSet) searchableItems.append(searchItem) 最後加到index裡 1234567CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) &#123; (error) -&amp;gt; Void in if error != nil &#123; print(error?.localizedDescription) &#125;else&#123; print(\"items indexed witch success!\") &#125;&#125; 醬子就好了！！！ 其中uniqueIdentifier可以在 continueUserActivity 的userInfo 被撈取 有沒有很方便呀 附記：index看起來沒有容量的限制，意思是…… 我可以塞爆他嗎？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"spotlight","slug":"spotlight","permalink":"http://ios.taipei/tags/spotlight/"}]},{"title":"取得手機現在正在用的語言","slug":"detectLanguage","date":"2018-05-03T15:00:00.000Z","updated":"2019-10-12T06:33:43.021Z","comments":true,"path":"2018/05/03/detectLanguage/","link":"","permalink":"http://ios.taipei/2018/05/03/detectLanguage/","excerpt":"Q: 這邊要教你取得手機現在正在用的語言","text":"Q: 這邊要教你取得手機現在正在用的語言 OBJC[[NSBundle mainBundle] preferredLocalizations];Swiftlet language = NSBundle.mainBundle().preferredLocalizations.first","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"Language","slug":"Language","permalink":"http://ios.taipei/tags/Language/"}]},{"title":"移除字串中的html tag","slug":"NoHtml","date":"2018-01-23T15:00:00.000Z","updated":"2019-10-12T06:31:14.242Z","comments":true,"path":"2018/01/23/NoHtml/","link":"","permalink":"http://ios.taipei/2018/01/23/NoHtml/","excerpt":"Q: 這邊要教你把html字串給清除掉","text":"Q: 這邊要教你把html字串給清除掉 OBJC-(NSString *) stringByStrippingHTML { NSRange r; NSString *s = [[self copy] autorelease]; while ((r = [s rangeOfString:@&quot;&lt;[^&gt;]+&gt;&quot; options:NSRegularExpressionSearch]).location != NSNotFound) s = [s stringByReplacingCharactersInRange:r withString:@&quot;&quot;]; return s; }swiftlet encodedString = &quot;HTML String&quot; guard let data = htmlEncodedString.data(using: .utf8) else { return nil } let options: [NSAttributedString.DocumentReadingOptionKey: Any] = [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ] guard let attributedString = try? NSAttributedString(data: data, options: options) else { return nil } let decodedString = attributedString.string","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"Extension","slug":"Extension","permalink":"http://ios.taipei/tags/Extension/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"Html","slug":"Html","permalink":"http://ios.taipei/tags/Html/"},{"name":"String","slug":"String","permalink":"http://ios.taipei/tags/String/"}]},{"title":"任意角的CornerRadius","slug":"CustomizedCornerRadius","date":"2017-05-13T15:00:00.000Z","updated":"2019-10-12T06:26:51.220Z","comments":true,"path":"2017/05/13/CustomizedCornerRadius/","link":"","permalink":"http://ios.taipei/2017/05/13/CustomizedCornerRadius/","excerpt":"Q: 這邊要教你把任意一個角給圓角化","text":"Q: 這邊要教你把任意一個角給圓角化 Extension extension UIView { func roundCorners(corners: UIRectCorner, radius: CGFloat) { let path = UIBezierPath(roundedRect: bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius)) let mask = CAShapeLayer() mask.path = path.cgPath layer.mask = mask } }實作 override func layoutSubviews() { super.layoutSubviews() roundCorners(corners: [.topLeft, .topRight, .bottomLeft], radius: 3.0) }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"cornerradius","slug":"cornerradius","permalink":"http://ios.taipei/tags/cornerradius/"},{"name":"CCLayer","slug":"CCLayer","permalink":"http://ios.taipei/tags/CCLayer/"},{"name":"Extension","slug":"Extension","permalink":"http://ios.taipei/tags/Extension/"}]},{"title":"如何知道網路通不通？","slug":"Conectivity","date":"2017-04-12T15:00:00.000Z","updated":"2019-10-12T06:00:25.917Z","comments":true,"path":"2017/04/12/Conectivity/","link":"","permalink":"http://ios.taipei/2017/04/12/Conectivity/","excerpt":"Q: 如何知道網路通不通？","text":"Q: 如何知道網路通不通？ Swift 將別人寫好的 Reachability 引用進來 https://github.com/ashleymills/Reachability.swift let reachability = Reachability()! reachability.whenReachable = { reachability in if reachability.connection == .wifi { print(&quot;Reachable via WiFi&quot;) } else { print(&quot;Reachable via Cellular&quot;) } } reachability.whenUnreachable = { _ in print(&quot;Not reachable&quot;) } do { try reachability.startNotifier() } catch { print(&quot;Unable to start notifier&quot;) } OBJC Reachability 引用 SystemConfiguration.Framework 將別人寫好的 Reachability 引用進來 https://github.com/tonymillion/Reachability 實作 interface #import &quot;Reachability.h&quot; @interface MyViewController () { Reachability *internetReachableFoo; } @end 實作 .m \\- (void)testInternetConnection { internetReachableFoo = [Reachability reachabilityWithHostname:@\"www.google.com\"]; internetReachableFoo.reachableBlock = ^(Reachability*reach) { dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;Yayyy, we have the interwebs!&quot;); }); }; internetReachableFoo.unreachableBlock = ^(Reachability*reach) { dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;Someone broke the internet :(&quot;); }); }; [internetReachableFoo startNotifier]; }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"網路","slug":"網路","permalink":"http://ios.taipei/tags/網路/"}]},{"title":"UIView 截圖","slug":"screenshots","date":"2017-04-12T15:00:00.000Z","updated":"2019-10-12T06:16:23.572Z","comments":true,"path":"2017/04/12/screenshots/","link":"","permalink":"http://ios.taipei/2017/04/12/screenshots/","excerpt":"Q: 這邊要教你把某一個UIView 的畫面重繪成圖片","text":"Q: 這邊要教你把某一個UIView 的畫面重繪成圖片 objcUIGraphicsBeginImageContextWithOptions(self.view.bounds.size, self.view.opaque, 0.0); [self.myView.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); NSData *imageData = UIImageJPEGRepresentation(image, 1.0 ); //you can use PNG too [imageData writeToFile:@&quot;image1.jpeg&quot; atomically:YES];Swiftfunc captureScreen() -&gt; UIImage { UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, false, 0); self.view.drawViewHierarchyInRect(view.bounds, afterScreenUpdates: true) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"CCLayer","slug":"CCLayer","permalink":"http://ios.taipei/tags/CCLayer/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"}]},{"title":"如何在程式裡放入字型檔","slug":"CustomizedFont","date":"2017-04-12T15:00:00.000Z","updated":"2019-10-12T06:09:34.208Z","comments":true,"path":"2017/04/12/CustomizedFont/","link":"","permalink":"http://ios.taipei/2017/04/12/CustomizedFont/","excerpt":"Q: 想使用不同的字型嗎？","text":"Q: 想使用不同的字型嗎？ 將自定義字體文件以資源(resource)的形式添加到專案中 在Info.plist中增加一個key-Array，key 的名稱必須為UIAppFonts 對於每種要加入的字體，必須輸入字體文件的全名（包括副檔字）作為 記得儲存info.plist UILabels、UITextViews或其他要使用自定義字體的地方調用[UIFont fontWithName：@“ CustomFontName” size：12] 就可以了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"字型","slug":"字型","permalink":"http://ios.taipei/tags/字型/"}]},{"title":"APP Size","slug":"AppSize","date":"2017-01-26T15:00:00.000Z","updated":"2019-10-12T13:39:36.863Z","comments":true,"path":"2017/01/26/AppSize/","link":"","permalink":"http://ios.taipei/2017/01/26/AppSize/","excerpt":"冷知識，app size最大可以到多少GB？","text":"冷知識，app size最大可以到多少GB？ (iOS only) App Size iOS App binary files can be as large as 4 GB, but each executable file (app_name.app/app_name) must not exceed 60 MB. Additionally, the total uncompressed size of the app must be less than 4 billion bytes. However, consider download times when determining your app’s size. Minimize the file’s size as much as possible, keeping in mind that there is a 100 MB limit for over-the-air downloads.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"APP Size","slug":"APP-Size","permalink":"http://ios.taipei/tags/APP-Size/"}]},{"title":"浮水印效果","slug":"watermark","date":"2017-01-26T15:00:00.000Z","updated":"2019-10-12T13:41:13.629Z","comments":true,"path":"2017/01/26/watermark/","link":"","permalink":"http://ios.taipei/2017/01/26/watermark/","excerpt":"這篇在描述，如何在圖片上面加文字，做出浮水印的效果","text":"這篇在描述，如何在圖片上面加文字，做出浮水印的效果 func textToImage(drawText text: String, inImage image: UIImage, atPoint point: CGPoint) -&gt; UIImage { let textColor = UIColor.white let textFont = UIFont(name: &quot;Helvetica Bold&quot;, size: 12)! let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(image.size, false, scale) let textFontAttributes = [ NSAttributedStringKey.font: textFont, NSAttributedStringKey.foregroundColor: textColor, ] as [NSAttributedStringKey : Any] image.draw(in: CGRect(origin: CGPoint.zero, size: image.size)) let rect = CGRect(origin: point, size: image.size) text.draw(in: rect, withAttributes: textFontAttributes) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"UIImage","slug":"UIImage","permalink":"http://ios.taipei/tags/UIImage/"}]},{"title":"NSZombie","slug":"NSZombie","date":"2016-10-10T15:00:00.000Z","updated":"2019-10-12T14:09:50.193Z","comments":true,"path":"2016/10/10/NSZombie/","link":"","permalink":"http://ios.taipei/2016/10/10/NSZombie/","excerpt":"什麼是僵屍? NSZombie？","text":"什麼是僵屍? NSZombie？ 在 build scheme diagnostics 下 有一個 zombie objects 的選項 在勾起來後，當你有object retain count == 0 但又沒有被釋放掉時，就像僵屍一樣，狀態是死掉的，但是卻一直存活在記憶體裡面，要死不活的佔在那裡。 在不穩定的程式裡，最好都要測看看 有沒有僵屍存活在你的程式裡","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"NSZombie","slug":"NSZombie","permalink":"http://ios.taipei/tags/NSZombie/"},{"name":"Memory","slug":"Memory","permalink":"http://ios.taipei/tags/Memory/"}]},{"title":"AutoLayout_Programmatically","slug":"AutoLayout_Programmatically","date":"2015-11-10T15:15:23.000Z","updated":"2015-11-10T10:06:46.000Z","comments":true,"path":"2015/11/10/AutoLayout_Programmatically/","link":"","permalink":"http://ios.taipei/2015/11/10/AutoLayout_Programmatically/","excerpt":"","text":"利用程式來加入 constraint首先 加兩個測試用的view 到 self.view 之中 UIView *redBlock = [[UIView alloc] init]; [redBlock setBackgroundColor:[UIColor redColor]]; [redBlock setTranslatesAutoresizingMaskIntoConstraints:NO]; [self.view addSubview:redBlock]; UIView *blueBlock = [[UIView alloc] init]; [blueBlock setBackgroundColor:[UIColor blueColor]]; [blueBlock setTranslatesAutoresizingMaskIntoConstraints:NO]; [self.view addSubview:blueBlock];結果圖 接著 開始撰寫這次要用的constraint 把握 X,Y,W,H 原則每一個物件在頁面上都有四種屬性 X,Y,Width,與Height，因此在撰寫auto layout constraint時，都要補足這四個原則，以下為範例 NSLayoutConstraint *constraintHeight = [NSLayoutConstraint constraintWithItem:redBlock attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeHeight multiplier:0.25 constant:0]; NSLayoutConstraint *constraintWidth = [NSLayoutConstraint constraintWithItem:redBlock attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeWidth multiplier:0.25 constant:0]; NSLayoutConstraint *constraintLeading = [NSLayoutConstraint constraintWithItem:redBlock attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeLeading multiplier:1 constant:20]; NSLayoutConstraint *constraintTop = [NSLayoutConstraint constraintWithItem:redBlock attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTop multiplier:1 constant:40]; [self.view addConstraint:constraintHeight]; [self.view addConstraint:constraintWidth]; [self.view addConstraint:constraintLeading]; [self.view addConstraint:constraintTop];樓上大意為 為紅色區域設定寛高為self.view的0.25倍，距離頁面左邊20，距離頁面上方40 NSLayoutConstraint *constraintHeight2 = [NSLayoutConstraint constraintWithItem:blueBlock attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:redBlock attribute:NSLayoutAttributeHeight multiplier:0.25 constant:0]; NSLayoutConstraint *constraintWidth2 = [NSLayoutConstraint constraintWithItem:blueBlock attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:redBlock attribute:NSLayoutAttributeWidth multiplier:0.25 constant:0]; NSLayoutConstraint *constraintLeading2 = [NSLayoutConstraint constraintWithItem:blueBlock attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:redBlock attribute:NSLayoutAttributeLeading multiplier:1 constant:20]; NSLayoutConstraint *constraintTop2 = [NSLayoutConstraint constraintWithItem:blueBlock attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:redBlock attribute:NSLayoutAttributeTop multiplier:1 constant:40]; [self.view addConstraint:constraintHeight2]; [self.view addConstraint:constraintWidth2]; [self.view addConstraint:constraintLeading2]; [self.view addConstraint:constraintTop2];樓上大意為 為藍色區域設定寛高為紅色區域的0.25倍，距離紅色區域左邊20，距離紅色區域上方40 Visual Format這是一種相對於constraint 比較簡單的寫法（比較不用一直加constraint） NSMutableArray *myConstraints = [NSMutableArray array]; [myConstraints addObjectsFromArray: [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-20-[redBlock(100)]-10-[blueBlock(&gt;=100)]-|&quot; options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(redBlock,blueBlock)]]; [myConstraints addObjectsFromArray: [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[redBlock(100)]-|&quot; options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(redBlock)]]; [myConstraints addObjectsFromArray: [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-30-[blueBlock(&gt;=120@750)]-30-|&quot; options:NSLayoutFormatDirectionLeadingToTrailing metrics:nil views:NSDictionaryOfVariableBindings(blueBlock,redBlock)]]; [self.view addConstraints:myConstraints];其中 V: &quot;、 &quot; H: &quot;分別代表由垂直或是水平方向來佈局。 &quot; | &quot;代表 Superview 的邊界。 &quot; [ ] &quot;代表物件本身，括號內包含物件的變數名稱與大小限制，可以使用關係運算子（&lt;＝、&gt;＝ 或 ＝＝ 等邏輯判斷）。 &quot; - &quot;代表預設寬度或高度，如果在中間加上數字 “ -30- “，則代表限制 30 個單位高度或寬度。兩側必需要銜接物件，以下為錯誤範例 （錯在20－20中間沒有物件相隔） [viewA]-20-20-[viewB] &quot; @ &quot;優先權，1 至 1000 的整數，優先權較大的條件會優先被滿足，例如 ，[viewA(&gt;=100@1000)]，物件 viewA 不可以小於 100 個單位長度或寬度會最優先被考慮。 結果圖","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"XCode7-ResourceOnDemand","slug":"XCode7-ResourceOnDemand","date":"2015-10-15T14:57:56.000Z","updated":"2015-10-15T07:45:38.000Z","comments":true,"path":"2015/10/15/XCode7-ResourceOnDemand/","link":"","permalink":"http://ios.taipei/2015/10/15/XCode7-ResourceOnDemand/","excerpt":"","text":"XCode7、iOS9新功能－Resource On Demand 資源檔分段下載XCode7的專案多了一個標籤[Resource Tags] 打開來看長這樣 接著解說一下各自的用意 Initial Install Tags: 在一開始安裝時就包在ipa裡讓人下載的資源檔 Prefetched Tag Order: 第一次開啟app時才下載資源檔 Download Only On Demand: 以程式判斷，需要下載時才下載（這段好像由apple代理，只要寫程式去抓資源檔回來） ##套用情境假設我寫了一個電子書app，全部資源檔包一包上傳到store，結果有30MB，此時手機如果在3G模式下，是沒有辦法下載這個app的（上限20MB），此時若將資源檔移至 [Prefetched Tag Order] 把主程式壓在20MB以下的話，3G模式下的使用者就可以下載了，另外的10MB，則是使用者第一次開啟時才會將這10MB下載回來。 內容的部份，我有10本書，每本10MB，如果在[Prefetched Tag Order]一口氣全下載回來的話，會慢到讓user以為是當機吧。所以內容可以等到使用者單獨開啟某一本書時再去下載，就可以放在[Download Only On Demand]，再用程式去判斷。 範例設定資源檔的tag在Images.xcassets找到需要設定的圖檔，並在且右方屬性的地方找找[On Demand Resources Tags]，如圖 打入[book1]，看起來很像標籤雲，實際上一個資源檔可以輸入多個tag，如圖 輸入完成後，回到[Resource Tags]看一眼，發現檔案自動出現在[Download Only On Demand] 呼叫程式下載資源檔iOS9 提供了兩個方法呼叫 看程式，bj4 beginAccessingResourcesWithCompletionHandler-(void)preloadResourceWithTags:(NSArray *)tagArray{ NSSet *tagSet = [NSSet setWithArray:tagArray]; NSBundleResourceRequest *resourceRequest = [[NSBundleResourceRequest alloc] initWithTags:tagSet]; [resourceRequest beginAccessingResourcesWithCompletionHandler:^(NSError * _Nullable error) { NSLog(@&quot;%@&quot;,error); }]; }conditionallyBeginAccessingResourcesWithCompletionHandler-(void)loadResourceWithTags:(NSArray *)tagArray{ NSSet *tagSet = [NSSet setWithArray:tagArray]; NSBundleResourceRequest *resourceRequest = [[NSBundleResourceRequest alloc] initWithTags:tagSet]; [resourceRequest conditionallyBeginAccessingResourcesWithCompletionHandler:^(BOOL resourcesAvailable) { if(resourcesAvailable){ NSLog(@&quot;Resources Available&quot;); } }]; }","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"漫談手機的存儲方式","slug":"漫談手機的存儲方式","date":"2015-08-17T11:54:13.000Z","updated":"2015-08-17T09:55:21.000Z","comments":true,"path":"2015/08/17/漫談手機的存儲方式/","link":"","permalink":"http://ios.taipei/2015/08/17/漫談手機的存儲方式/","excerpt":"","text":"如何在手機上存資料是我常常被問到的問題，因此開一篇文章來討論一下實務上幾個比較常見的到資料存儲方式，不過，這裡不會提到CoreData，原因在於－－－大部份的手機專案都是iOS／Android兩個手機專案在並行，因此大部份的owner會想要兩邊的流程是一致的，因此在選擇資料存儲的方式時，大多選擇兩個手機台平能夠共用的方式，sqlite就是一個比較好說服owner的方式。當然coredata也有他的好處和便捷性，這邊就不多解釋了。這裡要介紹的是 NSUserDefault、File與SQLite如果有人有更好的存儲方式，也請不吝告知。 NSUserDefault有許多型別可以使用，這裡使用比較常用的object當範例，其他類似的就不一一介紹。 regist Data[[NSUserDefaults standardUserDefaults] registerDefaults:&lt;#(NSDictionary *)#&gt;] [[NSUserDefaults standardUserDefaults] synchronize];write Data[[NSUserDefaults standardUserDefaults] setObject:data forKey:@&quot;key&quot;]; [[NSUserDefaults standardUserDefaults] synchronize];remove Data[[NSUserDefaults standardUserDefaults] removeObjectForKey:@&quot;key&quot;] [[NSUserDefaults standardUserDefaults] synchronize];或是 [[NSUserDefaults standardUserDefaults] setObject:nil forKey:@&quot;key&quot;]; [[NSUserDefaults standardUserDefaults] synchronize];read Data[[NSUserDefaults standardUserDefaults] objectForKey:@&quot;key&quot;]; [[NSUserDefaults standardUserDefaults] synchronize];實體檔案存取(NSFileManager)Create File- (void)createFileWithName:(NSString *)fileName { NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName]; NSFileManager *manager = [NSFileManager defaultManager]; if ([manager createFileAtPath:filePath contents:nil attributes:nil]) { NSLog(@&quot;Created the File Successfully.&quot;); } else { NSLog(@&quot;Failed to Create the File&quot;); } }Read File- (void)readFileWithName:(NSString *)fileName { NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName]; NSFileManager *manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath]) { NSError *error = nil; NSString *content = [NSString stringWithContentsOfFile:filePath encoding:NSStringEncodingConversionAllowLossy error:&amp;error]; NSLog(@&quot;File Content: %@&quot;, content); if (error) { NSLog(@&quot;There is an Error: %@&quot;, error); } } else { NSLog(@&quot;File %@ doesn&apos;t exists&quot;, fileName); } }Write File- (void)writeString:(NSString *)content toFile:(NSString *)fileName { NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName]; NSFileManager *manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath]) { NSError *error = nil; [content writeToFile:filePath atomically:YES encoding:NSStringEncodingConversionAllowLossy error:&amp;error]; if (error) { NSLog(@&quot;There is an Error: %@&quot;, error); } } else { NSLog(@&quot;File %@ doesn&apos;t exists&quot;, fileName); } }delete File- (void)deleteFileWithName:(NSString *)fileName { NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName]; NSFileManager *manager = [NSFileManager defaultManager]; // Need to check if the to be deleted file exists. if ([manager fileExistsAtPath:filePath]) { NSError *error = nil; [manager removeItemAtPath:filePath error:&amp;error]; if (error) { NSLog(@&quot;There is an Error: %@&quot;, error); } } else { NSLog(@&quot;File %@ doesn&apos;t exists&quot;, fileName); } }SQLite這裡我使用最常用的FMDB來當做範例FMDB on GitHub 首先你要先把 libsqlite3.dylib 加進library不解釋 OpenDBNSURL *appUrl = [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject]; NSString *dbPath = [[appUrl path] stringByAppendingPathComponent:@&quot;MyDatabase.db&quot;]; FMDatabase* db = [FMDatabase databaseWithPath:dbPath]; if (![db open]) { NSLog(@&quot;Could not open db&quot;); return; }insertDataif(![db executeUpdate:@&quot;INSERT INTO user (name, description) VALUES (?,?)&quot;, name, description]) { NSLog(@&quot;Could not insert data: %@&quot;, [db lastErrorMessage]); }這裡的代數是用？ readDataNSMutableArray* items = [NSMutableArray arrayWithCapacity:0]; FMResultSet *rs = [db executeQuery:@&quot;SELECT uid, name, description from user&quot;]; while ([rs next]) { int uid = [rs intForColumn:@&quot;uid&quot;]; NSString *name = [rs stringForColumn:@&quot;name&quot;]; NSString *description = [rs stringForColumn:@&quot;description&quot;]; [items addObject:[NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:uid], @&quot;uid&quot;, name, @&quot;name&quot;, description, @&quot;description&quot;, nil]]; } [rs close]; updateData[db beginTransaction]; if(![db executeUpdate:@&quot;UPDATE user set name=?, description＝? where name=&apos;?&apos;“,@&quot;1&quot;,@&quot;2&quot;,@&quot;1&quot;]); { NSLog(@&quot;Could not update data: %@&quot;, [db lastErrorMessage]); } [db commit];deleteDataif(![_db executeUpdate:@&quot;DELETE FROM user WHERE uid = ?&quot;, [NSNumber numberWithInt:uid]]) { NSLog(@&quot;Could not delete data: %@&quot;, [db lastErrorMessage]); }CloseDB[db close]執行FMDB的指令有她的生命週期，都是1.open db2.執行3.close db 如果沒有確實的open與close的話 是很容易造成exception而crash的最後，因為sqlite是以一個檔案型態存在的，因此在multi－thread讀寫資料時很容易出現錯誤，官方說明與建議的方法如下： Using a single instance of FMDatabase from multiple threads at once is a bad idea. It has always been OK to make a FMDatabase object per thread. Just don&apos;t share a single instance across threads, and definitely not across multiple threads at the same time. Bad things will eventually happen and you&apos;ll eventually get something to crash, or maybe get an exception, or maybe meteorites will fall out of the sky and hit your Mac Pro. This would suck. So don&apos;t instantiate a single FMDatabase object and use it across multiple threads. Instead, use FMDatabaseQueue. It&apos;s your friend and it&apos;s here to help. Here&apos;s how to use it: First, make your queue.用FMDatabaseQueue來解決，範例： FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath]; [queue inDatabase:^(FMDatabase *db) { [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;]; while ([rs next]) { … } }]; 就醬，其實不難～","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"XCode debug再進化－4","slug":"XCode-debug再進化-4","date":"2015-08-13T12:14:13.000Z","updated":"2015-08-13T07:17:15.000Z","comments":true,"path":"2015/08/13/XCode-debug再進化-4/","link":"","permalink":"http://ios.taipei/2015/08/13/XCode-debug再進化-4/","excerpt":"","text":"在xcode debug時，有些功能可能用不太到，不過既然知道了，就分享出來給大家知道，致於想不想用，什麼時候用，就端看自已的判斷了 這次是要介紹如何在debug模式下，新增watchpoint(監看點or監看式) 一樣先中斷一下吧在一個範例的按鈕裡裡先拉一個 IBAction 然後給一個中斷點 按下按鈕，被中斷後，在debug navagator的lldb裡下指令 watchpoint set variable i其中 watchpoint 是指令 可以簡寫為 watch variable 可以簡寫為 var i 就是你想要監看的東西然後就會出現如下的結果 Watchpoint created: Watchpoint 1: addr = 0x16fd25614 size = 4 state = enabled type = w declare @ &apos;/Users/minghongyu/Documents/work/iphone/test3/test3/ViewController.m:28&apos; watchpoint spec = &apos;i&apos; new value: 0 2015-08-13 20:02:38.367 test3[4700:525425] 0代表監看點新增成功 接著如果拿掉中斷點再繼續執行的話，會發現，每次都會自動停下來，結果如下 Watchpoint 1 hit: old value: 0 new value: 1 2015-08-13 20:02:42.329 test3[4700:525425] 1 Watchpoint 1 hit: old value: 1 new value: 2 2015-08-13 20:02:45.380 test3[4700:525425] 2 Watchpoint 1 hit: old value: 2 new value: 3 2015-08-13 20:02:48.603 test3[4700:525425] 3 Watchpoint 1 hit: old value: 3 new value: 4就可以好好的觀察變數的變化了 如果想看到所有的監看點列表，指令為 watchpoint list 也可以簡寫為 watch l （小寫L）執行的結果如下 Number of supported hardware watchpoints: 4 Current watchpoints: Watchpoint 1: addr = 0x16fd25614 size = 4 state = enabled type = w declare @ &apos;/Users/minghongyu/Documents/work/iphone/test3/test3/ViewController.m:28&apos; watchpoint spec = &apos;i&apos; old value: 3 new value: 4如果想要刪除監看點，指令為 watchpoint delete 1 也可以簡寫為 watch del 1其中 1 是列表中的順序數執行結果如下 1 watchpoints deleted.再繼續跑程式就不會停下來了！！ 無䭾無䭾無䭾無䭾無䭾無䭾無䭾無䭾無䭾無䭾無䭾無䭾無䭾！！！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"XCode debug再進化－3","slug":"XCode-debug再進化-3","date":"2015-08-13T12:14:13.000Z","updated":"2015-08-13T06:49:31.000Z","comments":true,"path":"2015/08/13/XCode-debug再進化-3/","link":"","permalink":"http://ios.taipei/2015/08/13/XCode-debug再進化-3/","excerpt":"","text":"在xcode debug時，有些功能可能用不太到，不過既然知道了，就分享出來給大家知道，致於想不想用，什麼時候用，就端看自已的判斷了 這次是要介紹如何在debug模式下，做到更新 UI 的指令 先中斷一下吧在一個範例的按鈕裡裡先拉一個 IBAction 然後給一個中斷點 在debug前的 UI 長成這樣 按下按鈕，被中斷後，在debug navagator的lldb裡下指令 e id $myView = (id)0x154d0e9d0其中 e 是 expresss 的簡寫 id 是型別 $myView 是變數容器 0x154d0e9d0 是記憶體位址 （需要與左側的變數的記憶體位址一致）結果如下圖 接著 可以輸入想要做的事情 e (void)[$myView setBackgroundColor:[UIColor redColor]]內容就不多解釋了，只是，醬子打完後 手機是不會動的（廢話，因為還卡在中斷點） 所以，要通知 UI 做更新才行 e (void)[CATransaction flush]你會發現，還在中斷點的debug模式下，手機的畫面更新了！！！！（如下圖） 真的太神奇了，傑克","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"XCode debug再進化－2","slug":"XCode-debug再進化-2","date":"2015-08-13T11:54:13.000Z","updated":"2015-08-13T06:20:17.000Z","comments":true,"path":"2015/08/13/XCode-debug再進化-2/","link":"","permalink":"http://ios.taipei/2015/08/13/XCode-debug再進化-2/","excerpt":"","text":"學海無涯，唯勤是岸，今天又要教一些xcode debug好用的小技巧了。這次是要介紹中斷點(BreakPoint)的使用 為你的程式加入中斷點先來一段小程式 for(int i=0;i&lt;100;i++){ NSLog(@&quot;%d&quot;,i); }接著 在旁邊的行數的區域用滑鼠點一下，就會看到中斷點的藍標跑出來想要移除中斷點可以用拖曳該中斷點 到中間的編輯區時會出現X，放掉就刪除了（有點像丟垃圾桶）。 接著，運行程式，會發現程式在一觸碰到中斷點時就會停下來等你debug 此時下方的[Debug Navigator]會自已彈出來會有一些基本的變數訊息在左邊 告訴我們此時 i=0; 當然，因為一碰到中斷點時馬上就停下來，所以i＝0時就停了 那…….我想要在 i=49 時，來做一個debug的動作呢？ =============== Of Course YES ================= =============== Of Course YES ================= =============== Of Course YES ================= 在breakpoint上滑鼠右鍵，並且選擇[Edit BreakPoint] 此時，會有幾個參數可以使用 1. Condition 2. Ignore 3. Action 4. Options - Automatically continue after evaluating actions在上述的情境中我們可以做的是 1. 在Condition 裡輸入 [ i == 49 ] 或 2. Ignore 48 接著重跑一次程式，媽呀～ 太神奇了，同樣的中斷點，程式跑到第49次才停下來！！！！！ 醬子的話 就可以隨心所欲的想中斷就中斷，不用一直按 [Step Over] 了","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"LinkedInSDK-Walk-Through","slug":"LinkedInSDK-Walk-Through","date":"2015-08-04T12:54:13.000Z","updated":"2015-08-04T09:13:45.000Z","comments":true,"path":"2015/08/04/LinkedInSDK-Walk-Through/","link":"","permalink":"http://ios.taipei/2015/08/04/LinkedInSDK-Walk-Through/","excerpt":"","text":"千呼萬喚始出來，LinkedIn終於把最後的一個ios sdk給補上了，就是這次要walk through的東西，不過很可惜的是目前只有objc版本，swift根據過往objc sdk的開發進度，我在想可能要等上個好一陣子了。 下載sdkSDK載點 準備開發環境 在開發者後台建立一個新旳應用程式 在開發者後台＞應用程式＞Mobile裡將Application Id 先記下來同時填寫1。iOS Bundle Identifiers2。iOS URL Suffix Schemes: 打開samplesdk的專案 修改info.plistkey：LIAppId value： [LinkedIn Application Id]修改url scheme 跑跑看 沒裝linkedin native app的話會提醒安裝 （不裝不能用） 據linkedin的開發者表示，這不會被apple reject，所以，有機會就來試看看會不會被reject吧 導回成功 但create session失敗（據說so是iOS 8.4的問題） 不過似乎沒有管道可以REPORT BUG，就只能慢慢等了","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"iOS 奇門遁甲指北針－CoreLocation的應用","slug":"iOS 奇門遁甲指北針－CoreLocation的應用","date":"2015-07-28T13:57:56.000Z","updated":"2015-07-28T15:24:24.000Z","comments":true,"path":"2015/07/28/iOS 奇門遁甲指北針－CoreLocation的應用/","link":"","permalink":"http://ios.taipei/2015/07/28/iOS 奇門遁甲指北針－CoreLocation的應用/","excerpt":"","text":"準備好一個新專案，以及CoreLocation.Framework 應該有的素材1。奇門遁甲圓盤 2。旋轉用的太極(裝飾用) 3。UISegment 切換「磁北」、「真北」 4。四個UILabel 顯示經緯度、高度、與方向角度程式的撰寫 info.plist NSLocationWhenInUseUsageDescription NSLocationAlwaysUsageDescriptionViewController.h #import &lt;CoreLocation/CoreLocation.h&gt; &lt;CLLocationManagerDelegate&gt; IBOutlet UIImageView *imgCompass; @property (nonatomic,retain) CLLocationManager *locationManager; @property (nonatomic,retain) CLHeading *currentHeading;ViewController.m - (void)viewDidLoad { [super viewDidLoad]; self.currentHeading = [[CLHeading alloc] init]; if ([CLLocationManager locationServicesEnabled]) //處理定位 { if([CLLocationManager authorizationStatus]==kCLAuthorizationStatusDenied){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;請先開啟定位&quot; delegate:self cancelButtonTitle:@&quot;確認&quot; otherButtonTitles:nil]; alert.tag =999; [self.view addSubview:alert]; [alert show]; isLocation = NO; return; }else{ isLocation = YES; self.locationManager = [[CLLocationManager alloc] init]; self.locationManager.desiredAccuracy = kCLLocationAccuracyBest; self.locationManager.headingFilter = 1; self.locationManager.delegate = self; if([locationManager respondsToSelector:@selector(requestWhenInUseAuthorization)]){ [locationManager requestWhenInUseAuthorization]; } [self.locationManager startUpdatingLocation]; } } else { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;請先開啟定位&quot; delegate:self cancelButtonTitle:@&quot;確認&quot; otherButtonTitles:nil]; alert.tag =999; [self.view addSubview:alert]; isLocation = NO; [alert show]; return; } [self.locationManager startUpdatingHeading]; } -(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations{ CLLocation* location = [locations objectAtIndex:0]; NSLog(@&quot;%f-%f&quot;,location.coordinate.latitude,location.coordinate.longitude); [[NSUserDefaults standardUserDefaults] setObject:[NSString stringWithFormat:@&quot;%f&quot;,location.coordinate.latitude] forKey:@&quot;Lat&quot;]; [[NSUserDefaults standardUserDefaults] setObject:[NSString stringWithFormat:@&quot;%f&quot;,location.coordinate.longitude] forKey:@&quot;Lng&quot;]; [[NSUserDefaults standardUserDefaults] setObject:[NSString stringWithFormat:@&quot;%f&quot;,location.altitude] forKey:@&quot;Alt&quot;]; [[NSUserDefaults standardUserDefaults] synchronize]; lblLat.text = [NSString stringWithFormat:@&quot;%f&quot;,location.coordinate.latitude]; lblLong.text = [NSString stringWithFormat:@&quot;%f&quot;,location.coordinate.longitude]; lblAlt.text = [NSString stringWithFormat:@&quot;%f&quot;,location.altitude]; } -(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error{ NSLog(@&quot;%@&quot;,error); } #pragma LocationManager Delegate -(void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading{ self.currentHeading = newHeading; if(segNorth.selectedSegmentIndex==1){ float heading = newHeading.magneticHeading; //in degrees float headingDegrees = (heading*M_PI/180); //assuming needle points to top of iphone. convert to radians imgCompass.transform = CGAffineTransformMakeRotation(headingDegrees); NSLog(@&quot;heading %f&quot;,heading); NSLog(@&quot;heading %f&quot;,headingDegrees); }else{ float heading = newHeading.trueHeading; //in degrees float headingDegrees = (heading*M_PI/180); //assuming needle points to top of iphone. convert to radians imgCompass.transform = CGAffineTransformMakeRotation(headingDegrees); NSLog(@&quot;heading %f&quot;,heading); NSLog(@&quot;heading %f&quot;,headingDegrees); } }完整專案放在 GitHub","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"TouchID Walk Through","slug":"TouchID","date":"2015-07-27T14:57:56.000Z","updated":"2015-08-06T02:29:24.000Z","comments":true,"path":"2015/07/27/TouchID/","link":"","permalink":"http://ios.taipei/2015/07/27/TouchID/","excerpt":"","text":"TouchID Walk Through每個人的心中，都有一個secrect box，用來存放一些不為人知的小秘密，然而，在iphone，也可以自已打造一倨屬於自已的secret box，接著，就是要介紹，如果打造一把只有自已能開鎖的這把鑰匙－－Touch ID 1。引用#import &lt;LocalAuthentication/LocalAuthentication.h&gt;2。加入程式- (IBAction)btnAuth:(id)sender { LAContext *context = [[LAContext alloc] init]; NSError *error = nil; if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) { [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@&quot;I need your finger print?&quot; reply:^(BOOL success, NSError *error) { if (error) { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;There was a problem verifying your identity.&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [self.view addSubview:alert]; [alert show]; return; } if (success) { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Success&quot; message:@&quot;You are the one I want!&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [self.view addSubview:alert]; [alert show]; } else { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;You are not the one I want.&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [self.view addSubview:alert]; [alert show]; } }]; } else { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;Your device cannot authenticate using TouchID.&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [alert show]; } }###3。看結果","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"XCode debug再進化","slug":"XCode-debug再進化","date":"2015-07-02T11:54:13.000Z","updated":"2015-08-13T03:19:12.000Z","comments":true,"path":"2015/07/02/XCode-debug再進化/","link":"","permalink":"http://ios.taipei/2015/07/02/XCode-debug再進化/","excerpt":"","text":"當然，要先來個crash 謝謝 Crashlytics 可以強制造成crash 基礎debug mode當crash發生時 xcode沒設定什麼東西時 程式會hang在這個讓人看不懂的地方 所以 要在xcode的地方設定一下 好方便未來的debug xcode左邊的panel 左邊數第7個 右邊倒數第2個頁籤 點下去－ 下面的「+」 點下去 選擇第一個「Add Exception Breakpoint」 這時候會變成這個專案專屬的exception breakpoint 此時xcode有個小貼心的地方，就是可以把breakpoint設為USER，往後，每一個新增的專案都會有這個exception breakpoint 結果變成 再重新執行一次crash，就會停在比較易讀的位置，也可以利用下方的debug console 來進行debug了 下方的debug console最常使用的指令是 po xxx如果你真的很想知道有那些指令的話，可以在debug console輸入help(不過我相信你絕對不會每一個都看完的) (lldb) help Debugger commands: apropos -- Find a list of debugger commands related to a particular word/subject. breakpoint -- A set of commands for operating on breakpoints. Also see _regexp-break. command -- A set of commands for managing or customizing the debugger commands. disassemble -- Disassemble bytes in the current function, or elsewhere in the executable program as specified by the user. expression -- Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. frame -- A set of commands for operating on the current thread&apos;s frames. gdb-remote -- Connect to a remote GDB server. If no hostname is provided, localhost is assumed. gui -- Switch into the curses based GUI mode. help -- Show a list of all debugger commands, or give details about specific commands. kdp-remote -- Connect to a remote KDP server. udp port 41139 is the default port number. log -- A set of commands for operating on logs. memory -- A set of commands for operating on memory. platform -- A set of commands to manage and create platforms. plugin -- A set of commands for managing or customizing plugin commands. process -- A set of commands for operating on a process. quit -- Quit out of the LLDB debugger. register -- A set of commands to access thread registers. script -- Pass an expression to the script interpreter for evaluation and return the results. Drop into the interactive interpreter if no expression is given. settings -- A set of commands for manipulating internal settable debugger variables. source -- A set of commands for accessing source file information target -- A set of commands for operating on debugger targets. thread -- A set of commands for operating on one or more threads within a running process. type -- A set of commands for operating on the type system version -- Show version of LLDB debugger. watchpoint -- A set of commands for operating on watchpoints. Current command abbreviations (type &apos;help command alias&apos; for more info): add-dsym -- (&apos;target symbols add&apos;) Add a debug symbol file to one of the target&apos;s current modules by specifying a path to a debug symbols file, or using the options to specify a module to download symbols for. attach -- (&apos;_regexp-attach&apos;) Attach to a process id if in decimal, otherwise treat the argument as a process name to attach to. b -- (&apos;_regexp-break&apos;) Set a breakpoint using a regular expression to specify the location, where &lt;linenum&gt; is in decimal and &lt;address&gt; is in hex. bt -- (&apos;_regexp-bt&apos;) Show a backtrace. An optional argument is accepted; if that argument is a number, it specifies the number of frames to display. If that argument is &apos;all&apos;, full backtraces of all threads are displayed. c -- (&apos;process continue&apos;) Continue execution of all threads in the current process. call -- (&apos;expression --&apos;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. continue -- (&apos;process continue&apos;) Continue execution of all threads in the current process. detach -- (&apos;process detach&apos;) Detach from the current process being debugged. di -- (&apos;disassemble&apos;) Disassemble bytes in the current function, or elsewhere in the executable program as specified by the user. dis -- (&apos;disassemble&apos;) Disassemble bytes in the current function, or elsewhere in the executable program as specified by the user. display -- (&apos;_regexp-display&apos;) Add an expression evaluation stop-hook. down -- (&apos;_regexp-down&apos;) Go down &quot;n&quot; frames in the stack (1 frame by default). env -- (&apos;_regexp-env&apos;) Implements a shortcut to viewing and setting environment variables. exit -- (&apos;quit&apos;) Quit out of the LLDB debugger. f -- (&apos;frame select&apos;) Select a frame by index from within the current thread and make it the current frame. file -- (&apos;target create&apos;) Create a target using the argument as the main executable. finish -- (&apos;thread step-out&apos;) Finish executing the function of the currently selected frame and return to its call site in specified thread (current thread, if none specified). image -- (&apos;target modules&apos;) A set of commands for accessing information for one or more target modules. j -- (&apos;_regexp-jump&apos;) Sets the program counter to a new address. jump -- (&apos;_regexp-jump&apos;) Sets the program counter to a new address. kill -- (&apos;process kill&apos;) Terminate the current process being debugged. l -- (&apos;_regexp-list&apos;) Implements the GDB &apos;list&apos; command in all of its forms except FILE:FUNCTION and maps them to the appropriate &apos;source list&apos; commands. list -- (&apos;_regexp-list&apos;) Implements the GDB &apos;list&apos; command in all of its forms except FILE:FUNCTION and maps them to the appropriate &apos;source list&apos; commands. n -- (&apos;thread step-over&apos;) Source level single step in specified thread (current thread, if none specified), stepping over calls. next -- (&apos;thread step-over&apos;) Source level single step in specified thread (current thread, if none specified), stepping over calls. nexti -- (&apos;thread step-inst-over&apos;) Single step one instruction in specified thread (current thread, if none specified), stepping over calls. ni -- (&apos;thread step-inst-over&apos;) Single step one instruction in specified thread (current thread, if none specified), stepping over calls. p -- (&apos;expression --&apos;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. po -- (&apos;expression -O -- &apos;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. print -- (&apos;expression --&apos;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. q -- (&apos;quit&apos;) Quit out of the LLDB debugger. r -- (&apos;process launch -c /bin/sh --&apos;) Launch the executable in the debugger. rbreak -- (&apos;breakpoint set -r %1&apos;) Sets a breakpoint or set of breakpoints in the executable. repl -- (&apos;expression -r -- &apos;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. run -- (&apos;process launch -c /bin/sh --&apos;) Launch the executable in the debugger. s -- (&apos;thread step-in&apos;) Source level single step in specified thread (current thread, if none specified). si -- (&apos;thread step-inst&apos;) Single step one instruction in specified thread (current thread, if none specified). step -- (&apos;thread step-in&apos;) Source level single step in specified thread (current thread, if none specified). stepi -- (&apos;thread step-inst&apos;) Single step one instruction in specified thread (current thread, if none specified). t -- (&apos;thread select&apos;) Select a thread as the currently active thread. tbreak -- (&apos;_regexp-tbreak&apos;) Set a one shot breakpoint using a regular expression to specify the location, where &lt;linenum&gt; is in decimal and &lt;address&gt; is in hex. undisplay -- (&apos;_regexp-undisplay&apos;) Remove an expression evaluation stop-hook. up -- (&apos;_regexp-up&apos;) Go up &quot;n&quot; frames in the stack (1 frame by default). x -- (&apos;memory read&apos;) Read from the memory of the process being debugged. For more information on any command, type &apos;help &lt;command-name&gt;&apos;.進階debug mode故事當然不會就醬子結束，breakpoint停在 1 [AppDelegate application:didFinishLaunchingWithOptions:] at /Users/minghongyu/Documents/work/iphone/OpenPoint/OpenPoint/AppDelegate.m:32如圖 但是 好像還有個 0 [Crashlytics crash] 會停在一堆機器碼的地方，真的讓人有點難以閱讀咧 接著在 debug console裡輸入(不要問，很可怕) po $arg1 發現他會吐出當下的crash的human－readable的解釋！！！！ 很重要 所以要說三次 真的是太好了！！！！！！ 真的是太好了！！！！！！ 真的是太好了！！！！！！但是 每次又要用手打 po ＄arg1 很辛苦有沒有？？很辛苦有沒有？？ 還好 xcode真的很貼心 在All Exception上按右鍵 選擇編輯「Edit Breakpoint」 點選「Add Action」 輸入 po $arg1 The End~ 有沒有很酷？ 有沒有? 有沒有?","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"Dungeon Generator","slug":"Dungeon Generator","date":"2015-06-30T10:10:12.000Z","updated":"2015-07-25T13:56:46.000Z","comments":true,"path":"2015/06/30/Dungeon Generator/","link":"","permalink":"http://ios.taipei/2015/06/30/Dungeon Generator/","excerpt":"","text":"diablo的亂數地圖是怎麼做的？還是直接用swift來寫一次 ###方法： 將矩形的地圖空間以「切割法」亂數切割房間，在切割的同時留一個出口， 反覆的切割後 就會得到一個亂數生成的房間了 範例牆壁－寛1 出口－寛1 GitHub下載連結","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"dropbox practice 2015","slug":"dropbox-practice-2015","date":"2015-06-15T16:25:47.000Z","updated":"2015-07-24T10:20:05.000Z","comments":true,"path":"2015/06/16/dropbox-practice-2015/","link":"","permalink":"http://ios.taipei/2015/06/16/dropbox-practice-2015/","excerpt":"","text":"手機也能透過sdk來讀取放在dropbox雲端空間的檔案！！利用dropbox來打造一個可以儲存讀取雲端空間的app吧只要跟著如下的步驟做就可以了 在APP Console開一個apphttps://www.dropbox.com/developers/apps 把其中的app key 和 app secret複製下來 下載sdk範例程式https://www.dropbox.com/developers/core/sdks/ios 把 app key 與 app secret貼到範例的delegate.m 裡 記得要設定根目錄 NSString *root = kDBRootDropbox;或 NSString *root = kDBRootAppFolder；設定url schema 讓 dropbox signon 可以回得來 好了的話就把程式run起來 拍洗 照片不給看～","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"Google Service 2015 Walk Through","slug":"Google-Service-2015-Walk-Through","date":"2015-06-09T15:55:30.000Z","updated":"2015-07-24T09:18:16.000Z","comments":true,"path":"2015/06/09/Google-Service-2015-Walk-Through/","link":"","permalink":"http://ios.taipei/2015/06/09/Google-Service-2015-Walk-Through/","excerpt":"","text":"2015 Google I/O 之後 很多東西都改了，所以來做一次walk through吧 比較特別的是 gcm也可以發ios了 https://developers.google.com/cloud-messaging/ try it on iOS 選擇語言 objc／swift 使用cocoapods安裝 gcm／analyticsPodfile pod &apos;Google/Analytics&apos; pod &apos;Google/CloudMessaging&apos;在所在目錄安裝 pod installpod 要確認是否為最新版本，不然安裝後會有錯誤完成之後打開workspace會看到一堆framework GCM的一些code- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Register for remote notifications UIUserNotificationType allNotificationTypes = (UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge); UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:allNotificationTypes categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; [[UIApplication sharedApplication] registerForRemoteNotifications]; return YES; } -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{ NSLog(@&quot;%@&quot;,deviceToken); [[GGLInstanceID sharedInstance] startWithConfig:[GGLInstanceIDConfig defaultConfig]]; _registrationOptions = @{kGGLInstanceIDRegisterAPNSOption:deviceToken, kGGLInstanceIDAPNSServerTypeSandboxOption:@YES}; [[GGLInstanceID sharedInstance] tokenWithAuthorizedEntity:@&quot;gswt-ea275&quot; scope:kGGLInstanceIDScopeGCM options:_registrationOptions handler:nil]; } -(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error{ NSLog(@&quot;%@&quot;,error); }GA的一些code-(void)GAScreen:(NSString *)name{ dispatch_queue_t myQueue = dispatch_queue_create(&quot;GAQueue&quot;,NULL); dispatch_async(myQueue, ^{ id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker]; [tracker set:kGAIScreenName value:name]; [tracker send:[[GAIDictionaryBuilder createScreenView] build]]; }); } -(void)GAEvent:(NSString *)CATEGORY :(NSString *)ACTION :(NSString *)LABEL :(NSNumber *)Value{ dispatch_queue_t myQueue = dispatch_queue_create(&quot;GAQueue&quot;,NULL); dispatch_async(myQueue, ^{ id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker]; [tracker send:[[GAIDictionaryBuilder createEventWithCategory:CATEGORY action:ACTION label:LABEL value:Value] build]]; }); }希望對大家有幫助","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"swift shuffle","slug":"swift-shuffle","date":"2015-05-27T15:33:44.000Z","updated":"2015-07-25T13:43:25.000Z","comments":true,"path":"2015/05/27/swift-shuffle/","link":"","permalink":"http://ios.taipei/2015/05/27/swift-shuffle/","excerpt":"","text":"為程式注入靈魂的小技巧 shufflefunc shuffle&lt;C: MutableCollectionType where C.Index == Int&gt;(var list: C) -&gt; C { let c = count(list) for i in 0..&lt;(c - 1) { let j = Int(arc4random_uniform(UInt32(c - i))) + i swap(&amp;list[i], &amp;list[j]) } return list } huffle([1, 2, 3, 4, 5, 6, 7, 8]) // e.g., [6, 1, 8, 3, 2, 4, 7, 5] shuffle([&quot;hello&quot;, &quot;goodbye&quot;, &quot;ciao&quot;]) // e.g., [&quot;ciao&quot;, &quot;goodbye&quot;, &quot;hello&quot;]extensionextension Array { mutating func shuffle() { for i in 0..&lt;(count - 1) { let j = Int(arc4random_uniform(UInt32(count - i))) + i swap(&amp;self[i], &amp;self[j]) } } } var numbers = [1, 2, 3, 4, 5, 6, 7, 8] numbers.shuffle()","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"swift spritekit walk through","slug":"swift-spritekit-walk-through","date":"2015-05-26T09:06:03.000Z","updated":"2015-07-24T09:11:47.000Z","comments":true,"path":"2015/05/26/swift-spritekit-walk-through/","link":"","permalink":"http://ios.taipei/2015/05/26/swift-spritekit-walk-through/","excerpt":"","text":"新增一個遊戲專案 並且設定語言為swift 此時，可以先砍掉一些沒有必要的檔案（iOS很貼心放了一個太空船在程式的template裡） 加入一些遊戲需要用到的圖檔 你可以放在images.asset或是直接拉到專案裡 設一下GameViewController裡的 scene.sizescene.size = skView.bounds.size了解scene的生命週期、座標系統、基本屬性了解sprite基本屬性了解texture基本屬性、打包textureAtlas(zip file with .altas)了解Action基本屬性了解Animation基本屬性了解Physicsgame loop？？","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"遊戲","slug":"遊戲","permalink":"http://ios.taipei/tags/遊戲/"}]},{"title":"在字串裡加上icon","slug":"在字串裡加上icon","date":"2015-05-21T03:46:16.000Z","updated":"2015-07-25T14:04:39.000Z","comments":true,"path":"2015/05/21/在字串裡加上icon/","link":"","permalink":"http://ios.taipei/2015/05/21/在字串裡加上icon/","excerpt":"","text":"在UILabel裡要怎麼做到呢？ABC CDE NSTextAttachment *attachment = [[NSTextAttachment alloc] init]; attachment.image = [UIImage imageNamed:@&quot;MyIcon.png&quot;]; NSAttributedString *attachmentString = [NSAttributedString attributedStringWithAttachment:attachment]; NSMutableAttributedString *myString= [[NSMutableAttributedString alloc] initWithString:@&quot;My label text&quot;]; [myString appendAttributedString:attachmentString]; myLabel.attributedText = myString;不難懂～","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"2015 AudioToolBox walk through ","slug":"2015-AudioToolBox-walk-through","date":"2015-05-15T14:42:44.000Z","updated":"2015-07-25T14:04:00.000Z","comments":true,"path":"2015/05/15/2015-AudioToolBox-walk-through/","link":"","permalink":"http://ios.taipei/2015/05/15/2015-AudioToolBox-walk-through/","excerpt":"","text":"google出很多版本，沒幾個能用的，看官網後試出來的 NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;button_click&quot; ofType:@&quot;mp3&quot;]; NSURL *filePath = [NSURL fileURLWithPath:path]; OSStatus status1 = AudioServicesCreateSystemSoundID((__bridge CFURLRef)filePath, &amp;soundFileObject); NSLog(@&quot;%d&quot;,(int)status1); AudioServicesPlaySystemSound (soundFileObject);話說 osstatus 好像有點新，如果有人可以分享的話，那是再好也不過的事了","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"iOS Language ID","slug":"iOS-Language-ID","date":"2015-05-15T12:23:31.000Z","updated":"2015-07-25T13:55:08.000Z","comments":true,"path":"2015/05/15/iOS-Language-ID/","link":"","permalink":"http://ios.taipei/2015/05/15/iOS-Language-ID/","excerpt":"","text":"Language .lporj Language Code English en English (British) en-GB English (Australian) en-AU English (Canadian) en-CA English (Indian) en-IN French fr French (Canadian) fr-CA Spanish es Spanish (Mexico) es-M Portuguese pt Portuguese (Brazil) pt-BR Italian it German de Chinese Chinese (Simplified) zh-Hans Chinese (Traditional) zh-Hant Chinese (Hong Kong) zh-HK Dutch nl Japanese ja Korean ko Vietnamese vi Russian ru Swedish sv Danish da Finnish fi Norwegian (Bokmal) nb Turkish tr Greek el Indonesian id Malay ms Thai th Hindi hi Hungarian hu Polish pl Czech cs Slovak sk Ukrainian uk Croatian hr Catalan ca Romanian ro Hebrew he Arabic ar","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"inApp Purchase walkthrough","slug":"inApp-Purchase-walkthrough","date":"2015-05-12T07:14:47.000Z","updated":"2015-07-24T09:16:00.000Z","comments":true,"path":"2015/05/12/inApp-Purchase-walkthrough/","link":"","permalink":"http://ios.taipei/2015/05/12/inApp-Purchase-walkthrough/","excerpt":"","text":"前言 2015-05別人的walk through都有點年代了，而且關鍵的幾個點都沒有特別註明，所以只好自已來寫一個walk through unique App ID意思是不可以使用Wildcard App ID來做APP的綁定（如果出現*是不允許的） [member center] - [Certificates, Identifiers &amp; Profiles] - [App IDs]Provisioning Profileprovision profile要與App ID匹配 ItunesConnect 設定APP新增一個app，該填的填 新增 inAPP Product[APP] - [App 內購買項目] - [Create New] - [非消耗性項目] 非消耗性項目 把讓填的填一填後[儲存] ProductID 一定要是 appid.name在這裡卡關很久，很多walk through說ProdoctID只要unique，但是程式寫好，按下去就是 [StoreStateInvalidProduct]，要記得全部都要帶 (範例為) com.yuaki.No5.Remove_AD 檢查xcode裡iap的設定是否開啟 Code加入 StoreKit.Framework 加入三支程式 Store.h、Store.m和一支放在server的iap.php感謝 Paul Wu 大大的無私分享store.h // // Store.h // DemoIAP // // Created by Paul Wu on 2014/11/23. // Copyright (c) 2014年 Prodisky. All rights reserved. // #import &lt;Foundation/Foundation.h&gt; enum { StoreStatePurchasing, StoreStatePurchased, StoreStateRestored, StoreStateDeferred, StoreStateVerifyReceipt, StoreStateMakePaymentsFail, StoreStateInvalidProduct, StoreStateFailedClientInvalid, StoreStateFailedPaymentCancelled, StoreStateFailedPaymentInvalid, StoreStateFailedPaymentNotAllowed, StoreStateFailedUnknown }; typedef NSUInteger StoreState; #import &lt;Foundation/Foundation.h&gt; #import &lt;StoreKit/StoreKit.h&gt; @interface Store : NSObject &lt;SKPaymentTransactionObserver, SKProductsRequestDelegate&gt; @property (nonatomic, copy) void (^updatedState) (StoreState state, NSString *productIdentifier); @property (nonatomic, copy) void (^verifyPass) (NSString *productIdentifier); @property (nonatomic, copy) void (^verifyFail) (NSString *productIdentifier); + (Store*)shared; - (void)purchase:(NSString *)productIdentifier; - (void)restore; @endstore.m // // Store.m // DemoIAP // // Created by Paul Wu on 2014/11/23. // Copyright (c) 2014年 Prodisky. All rights reserved. // #import &quot;Store.h&quot; #define verifyServerURL @&quot;http://XXX/iap.php&quot; #pragma mark @interface URLRequest : NSMutableURLRequest @property (nonatomic, copy) void (^didFinish) (NSData* response); @property (nonatomic, copy) void (^didError) (NSError *error); - (void) startAsynchronous; @end @interface URLRequest () { NSMutableData *responseData; NSURLConnection *urlconnection; }@end @implementation URLRequest - (id)init { if (self = [super init]) { self.timeoutInterval = 3.14; self.HTTPShouldUsePipelining = YES; } return self; } - (void)startAsynchronous { urlconnection = [[NSURLConnection alloc] initWithRequest:self delegate:self]; } - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response { responseData = [NSMutableData new]; } - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data { [responseData appendData:data]; } - (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error { [urlconnection cancel]; responseData = [NSMutableData new]; if (_didError) _didError(error); } - (void)connectionDidFinishLoading:(NSURLConnection *)connection { [urlconnection cancel]; urlconnection = nil; if (_didFinish) _didFinish(responseData); } @end #pragma mark @implementation Store static Store *_shared = nil; + (Store*)shared { if (_shared == nil) _shared = [self new]; return _shared; } - (void)verifyReceipt:(SKPaymentTransaction *)transaction { NSString *parameterString = [NSString stringWithFormat:@&quot;receipt=%@&quot;, [[NSBundle mainBundle] appStoreReceiptURL]]; URLRequest *request = [URLRequest new]; request.URL = [NSURL URLWithString:verifyServerURL]; request.cachePolicy = NSURLRequestReloadIgnoringLocalAndRemoteCacheData; request.HTTPBody = [parameterString dataUsingEncoding:NSUTF8StringEncoding]; request.HTTPMethod = @&quot;POST&quot;; [request setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; request.didFinish = ^(NSData* response) { NSError* error; NSDictionary* json = [NSJSONSerialization JSONObjectWithData:response options:kNilOptions error:&amp;error]; if ([[json objectForKey:@&quot;result&quot;] integerValue] &gt; 0) { if (_verifyPass) _verifyPass(transaction.payment.productIdentifier); } else { if (_verifyFail) _verifyFail(transaction.payment.productIdentifier); } }; request.didError = ^(NSError *error){ if (_verifyFail) _verifyFail(transaction.payment.productIdentifier); }; [request startAsynchronous]; } - (id)init { if (self = [super init]) { [[SKPaymentQueue defaultQueue] addTransactionObserver:self]; } return self; } - (void)purchase:(NSString *)productIdentifier { if ([SKPaymentQueue canMakePayments]) { SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:[NSSet setWithObject:productIdentifier]]; request.delegate = self; [request start]; } else { if (_updatedState) _updatedState(StoreStateMakePaymentsFail, productIdentifier); } } - (void)restore { [[SKPaymentQueue defaultQueue] restoreCompletedTransactions]; } - (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response { if ([response.invalidProductIdentifiers count] == 0) { for (NSUInteger i = 0; i &lt; [response.products count]; i++) { SKProduct *product = [response.products objectAtIndex:i]; SKPayment *payment = [SKPayment paymentWithProduct:product]; [[SKPaymentQueue defaultQueue] addPayment:payment]; } } else { if (_updatedState) for (NSUInteger i = 0; i &lt; [response.invalidProductIdentifiers count]; i++) _updatedState(StoreStateInvalidProduct, [response.invalidProductIdentifiers objectAtIndex:i]); } } - (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions { for (SKPaymentTransaction *transaction in transactions) { if (transaction.transactionState != SKPaymentTransactionStatePurchasing) [[SKPaymentQueue defaultQueue] finishTransaction: transaction]; if (_updatedState) { switch (transaction.transactionState) { case SKPaymentTransactionStatePurchasing: _updatedState(StoreStatePurchasing, transaction.payment.productIdentifier); break; case SKPaymentTransactionStatePurchased: _updatedState(StoreStatePurchased, transaction.payment.productIdentifier); break; case SKPaymentTransactionStateFailed: switch (transaction.error.code) { case SKErrorClientInvalid: _updatedState(StoreStateFailedClientInvalid, transaction.payment.productIdentifier); break; case SKErrorPaymentCancelled: _updatedState(StoreStateFailedPaymentCancelled, transaction.payment.productIdentifier); break; case SKErrorPaymentInvalid: _updatedState(StoreStateFailedPaymentInvalid, transaction.payment.productIdentifier); break; case SKErrorPaymentNotAllowed: _updatedState(StoreStateFailedPaymentNotAllowed, transaction.payment.productIdentifier); break; case SKErrorUnknown: default: _updatedState(StoreStateFailedUnknown, transaction.payment.productIdentifier); break; } break; case SKPaymentTransactionStateRestored: _updatedState(StoreStateRestored, transaction.payment.productIdentifier); break; case SKPaymentTransactionStateDeferred: //iOS 8 and later. _updatedState(StoreStateDeferred, transaction.payment.productIdentifier); break; } } if (transaction.transactionState == SKPaymentTransactionStatePurchased || transaction.transactionState == SKPaymentTransactionStateRestored) [self verifyReceipt:transaction]; } } @endServer code - iap.php &lt;?php function verify($receipt) { if (empty($receipt)) { $result[&quot;result&quot;] = 0; return $result; } $dataToPost = json_encode(array(&quot;receipt-data&quot; =&gt; $receipt)); $opts = array(&apos;http&apos; =&gt; array( &apos;method&apos; =&gt; &apos;POST&apos;, &apos;header&apos; =&gt; &apos;Content-type: application/x-www-form-urlencoded&apos;, &apos;content&apos; =&gt; $dataToPost ) ); $context = stream_context_create($opts); $verifyResult = file_get_contents(&apos;https://buy.itunes.apple.com/verifyReceipt&apos;, false, $context); $verifyStatus = json_decode($verifyResult); if ($verifyStatus-&gt;{&apos;status&apos;} == 0) { $result[&quot;result&quot;] = 1; return $result; } $verifyResult = file_get_contents(&apos;https://sandbox.itunes.apple.com/verifyReceipt&apos;, false, $context); $verifyStatus = json_decode($verifyResult); if ($verifyStatus-&gt;{&apos;status&apos;} == 0) { $result[&quot;result&quot;] = 2; return $result; } $result[&quot;result&quot;] = -2; return $result; } echo json_encode(verify($_REQUEST[&quot;receipt&quot;])); ?&gt;使用購買 [[Store shared] purchase:@&quot;com.yuaki.No5.Remove_AD&quot;];回復購買產品動作 [[Store shared] restore]; 其他-(void)checkStore{ [Store shared].updatedState = ^(StoreState state, NSString *productIdentifier) { //需要顯示購買過程時使用。 switch (state) { case StoreStatePurchasing: NSLog(@&quot;StoreStatePurchasing %@&quot;, productIdentifier); break; case StoreStatePurchased: NSLog(@&quot;StoreStatePurchased %@&quot;, productIdentifier); break; case StoreStateRestored: NSLog(@&quot;StoreStateRestored %@&quot;, productIdentifier); [self performSelector:@selector(checkStore) withObject:nil afterDelay:5.0f]; break; case StoreStateDeferred: NSLog(@&quot;StoreStateDeferred %@&quot;, productIdentifier); break; case StoreStateVerifyReceipt: NSLog(@&quot;StoreStateVerifyReceipt %@&quot;, productIdentifier); break; case StoreStateMakePaymentsFail: [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;付款失敗&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; NSLog(@&quot;StoreStateMakePaymentsFail %@&quot;, productIdentifier); break; case StoreStateInvalidProduct: NSLog(@&quot;StoreStateInvalidProduct %@&quot;, productIdentifier); [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;產品id無效&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; break; case StoreStateFailedClientInvalid: NSLog(@&quot;StoreStateFailedClientInvalid %@&quot;, productIdentifier); break; case StoreStateFailedPaymentCancelled: NSLog(@&quot;StoreStateFailedPaymentCancelled %@&quot;, productIdentifier); [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;付款取消&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; break; case StoreStateFailedPaymentInvalid: NSLog(@&quot;StoreStateFailedPaymentInvalid %@&quot;, productIdentifier); [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;付款失效&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; break; case StoreStateFailedPaymentNotAllowed: NSLog(@&quot;StoreStateFailedPaymentNotAllowed %@&quot;, productIdentifier); [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;不允許付款&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; break; case StoreStateFailedUnknown: [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;付款有未知的錯誤&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; NSLog(@&quot;StoreStateFailedUnknown %@&quot;, productIdentifier); break; } }; [Store shared].verifyPass = ^(NSString *productIdentifier) { [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;購買成功&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; //remove AD }; [Store shared].verifyFail = ^(NSString *productIdentifier) { [[[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;購買失敗&quot; delegate:self cancelButtonTitle:@&quot;確定&quot; otherButtonTitles:nil] show]; }; }沙箱測試新增測試人員[使用者和職能] - [測試人員] - [+] 該填的填一填 好玩的是，不能使用既有的appid當做沙箱測試人員，只好去申請一個新的email來測試。 在手機上[App Store] &gt; [精選項目] &gt; [登入] 沙箱測試人員 接著就可以進行購買測試了 打完收功","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"add MotionEffect for your UIView","slug":"add-MotionEffect-for-your-UIView","date":"2015-05-05T15:15:23.000Z","updated":"2015-07-25T14:03:01.000Z","comments":true,"path":"2015/05/05/add-MotionEffect-for-your-UIView/","link":"","permalink":"http://ios.taipei/2015/05/05/add-MotionEffect-for-your-UIView/","excerpt":"","text":"為你的 UIView 加上 Motion的效果 UIInterpolatingMotionEffect *xAxis = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.x&quot; type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; xAxis.maximumRelativeValue = @(40); xAxis.minimumRelativeValue = @(-40); UIInterpolatingMotionEffect *yAxis = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.y&quot; type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; yAxis.maximumRelativeValue = @(40); yAxis.minimumRelativeValue = @(-40); UIMotionEffectGroup *group = [[UIMotionEffectGroup alloc] init]; group.motionEffects = @[xAxis,yAxis]; [btnMap addMotionEffect:group];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"make UIRefreshControll by your self","slug":"make-UIRefreshControll-by-your-self","date":"2015-05-05T15:06:53.000Z","updated":"2015-07-25T13:52:18.000Z","comments":true,"path":"2015/05/05/make-UIRefreshControll-by-your-self/","link":"","permalink":"http://ios.taipei/2015/05/05/make-UIRefreshControll-by-your-self/","excerpt":"","text":"##裡面用到了幾個技示巧 1。 旋轉的animation2。 移動的animation3。 移除不必要的UIActivityIndicator bikeRegreshConrtol.h#import &lt;UIKit/UIKit.h&gt; @interface bikeRegreshConrtol : UIRefreshControl -(void)makeAnimate; @endbikeRegreshConrtol.m#import “bikeRegreshConrtol.h” @implementation bikeRegreshConrtol -(instancetype)init{ self = [super init]; if (self) { } return self; } -(void)makeAnimate{ for (UIView *V in self.subviews) { if ([[V class] isSubclassOfClass:[UIImageView class]]) { NSLog(@&quot;%@&quot;,[V class]); }else{ [V removeFromSuperview]; } } UIImageView *wheel1 = [[UIImageView alloc] initWithImage: [UIImage imageNamed: @&quot;wheel.png&quot;]]; [wheel1 setFrame:CGRectMake(50, self.center.y, 30, 30)]; UIImageView *wheel2 = [[UIImageView alloc] initWithImage: [UIImage imageNamed: @&quot;wheel.png&quot;]]; [wheel2 setFrame:CGRectMake(90, self.center.y, 30, 30)]; if ([wheel1.layer animationForKey:@&quot;SpinAnimation&quot;] == nil) { CABasicAnimation* animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; animation.fromValue = [NSNumber numberWithFloat:0.0f]; animation.toValue = [NSNumber numberWithFloat: 2*M_PI]; animation.duration = 2.4f; animation.repeatCount = INFINITY; [wheel1.layer addAnimation:animation forKey:@&quot;SpinAnimation&quot;]; } if ([wheel2.layer animationForKey:@&quot;SpinAnimation&quot;] == nil) { CABasicAnimation* animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; animation.fromValue = [NSNumber numberWithFloat:0.0f]; animation.toValue = [NSNumber numberWithFloat: 2*M_PI]; animation.duration = 2.2f; animation.repeatCount = INFINITY; [wheel2.layer addAnimation:animation forKey:@&quot;SpinAnimation&quot;]; } [self insertSubview:wheel1 atIndex:3]; [self insertSubview:wheel2 atIndex:2]; UIImageView *back1 = [[UIImageView alloc] initWithImage: [UIImage imageNamed: @&quot;background.png&quot;]]; [back1 setFrame:CGRectMake(0, 0, self.bounds.size.width, self.bounds.size.height)]; [self insertSubview:back1 atIndex:1]; UIImageView *back2 = [[UIImageView alloc] initWithImage: [UIImage imageNamed: @&quot;background.png&quot;]]; [back2 setFrame:CGRectMake(320, 0, self.bounds.size.width, self.bounds.size.height)]; [self insertSubview:back2 atIndex:0]; [self bringSubviewToFront:wheel1]; [self bringSubviewToFront:wheel2]; // [self doAnimate:back1 :back2]; } -(void)doAnimate:(UIImageView *)img :(UIImageView *)img2{ [UIView animateWithDuration:32.0f animations:^{ [img setFrame:CGRectMake(-320, 0, img.frame.size.width, img.frame.size.height)]; [img2 setFrame:CGRectMake(0, 0, img.frame.size.width, img.frame.size.height)]; } completion:^(BOOL finished) { [img setFrame:CGRectMake(0, 0, img.frame.size.width, img.frame.size.height)]; [img2 setFrame:CGRectMake(320, 0, img.frame.size.width, img.frame.size.height)]; [self doAnimate:img :img2]; }]; }使用refreshControl = [[bikeRegreshConrtol alloc] init]; [refreshControl addTarget:self action:@selector(refresh) forControlEvents:UIControlEventValueChanged]; [mTable addSubview:refreshControl]; [refreshControl makeAnimate];更新結束[refreshControl endRefreshing];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"make HUD by your self","slug":"make-HUD-by-your-self","date":"2015-05-04T01:24:52.000Z","updated":"2015-07-25T13:53:43.000Z","comments":true,"path":"2015/05/04/make-HUD-by-your-self/","link":"","permalink":"http://ios.taipei/2015/05/04/make-HUD-by-your-self/","excerpt":"","text":"首先，需要一個singleton來統管這個HUD，避免一次出現兩個hud以上的窘境static LoadingView *myInstance = nil; +(LoadingView *)shared { // check to see if an instance already exists if (nil == myInstance) { myInstance = [[[self class] alloc] init]; // initialize variables here } // return the instance of this class return myInstance; }接著實作兩個 instanceMethod+ (void)dismiss{ [[UIApplication sharedApplication] endIgnoringInteractionEvents]; [[self shared] selfHide]; } + (void)show { [[UIApplication sharedApplication] beginIgnoringInteractionEvents]; [[self shared] selfShow]; }兩個class method自window中找到hud並移除 -(void)selfHide{ [[((AppDelegate *)([UIApplication sharedApplication].delegate)).window viewWithTag:56789] removeFromSuperview]; [[((AppDelegate *)([UIApplication sharedApplication].delegate)).window viewWithTag:56790] removeFromSuperview]; }將hud加到最上層的window，範例中的hud為中間一個靜置圖片，週遭再放一個不斷旋轉的圖片 -(void)selfShow{ UIImageView *mView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; [mView setImage:[UIImage imageNamed:@&quot;loading.png&quot;]]; mView.tag = 56789; [mView setCenter:((AppDelegate *)([UIApplication sharedApplication].delegate)).window.center]; UIImageView *mView2 = [[UIImageView alloc] initWithFrame:CGRectMake(0,0, 100, 100)]; [mView2 setImage:[UIImage imageNamed:@&quot;loading2.png&quot;]]; mView2.tag = 56790; [mView2 setCenter:mView.center]; if ([mView2.layer animationForKey:@&quot;SpinAnimation&quot;] == nil) { CABasicAnimation* animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; animation.fromValue = [NSNumber numberWithFloat:0.0f]; animation.toValue = [NSNumber numberWithFloat: 2*M_PI]; animation.duration = 1.0f; animation.repeatCount = INFINITY; [mView2.layer addAnimation:animation forKey:@&quot;SpinAnimation&quot;]; } [((AppDelegate *)([UIApplication sharedApplication].delegate)).window addSubview:mView]; [((AppDelegate *)([UIApplication sharedApplication].delegate)).window addSubview:mView2]; }接著，在其他地方引用，再呼叫 [LoadingView show]、[LoadingView dismiss] 就可以了","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"取得MKMapView的Zoom Level","slug":"取得MKMapView的Zoom-Level","date":"2015-04-23T06:23:08.000Z","updated":"2015-07-25T14:03:32.000Z","comments":true,"path":"2015/04/23/取得MKMapView的Zoom-Level/","link":"","permalink":"http://ios.taipei/2015/04/23/取得MKMapView的Zoom-Level/","excerpt":"","text":"定義地球弧度 #define MERCATOR_RADIUS 85445659.44705395 Method - (int)getZoomLevel:(MKMapView*)_mapView { return 21－round(log2(_mapView.region.span.longitudeDelta * MERCATOR_RADIUS * M_PI / (180.0 * _mapView.bounds.size.width))); } 測試一下 - (void)mapView:(MKMapView *)_mapView regionDidChangeAnimated:(BOOL)animated { NSLog(@&quot;zoom level %d&quot;, [self getZoomLevel:_mapView]); }","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"iBeacon Scanner實作概念","slug":"iBeacon-Scanner實作概念","date":"2015-04-22T04:10:24.000Z","updated":"2015-07-25T13:56:31.000Z","comments":true,"path":"2015/04/22/iBeacon-Scanner實作概念/","link":"","permalink":"http://ios.taipei/2015/04/22/iBeacon-Scanner實作概念/","excerpt":"","text":"1. 利用 CoreBluetoooth 來找尋附近的藍芽裝置Code Snippet #import &lt;CoreBluetooth/CoreBluetooth.h&gt; @interface ViewController ()&lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt; { CBCentralManager *_manager; CBPeripheral *_peripheral; } @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; _manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; } - (void)centralManagerDidUpdateState:(CBCentralManager *)central { switch ((int)central.state) { case CBCentralManagerStatePoweredOn: { NSDictionary *options = @{ CBCentralManagerScanOptionAllowDuplicatesKey: @YES }; [_manager scanForPeripheralsWithServices:nil options:options]; NSLog(@&quot;I just started scanning for peripherals&quot;); break; } } } - (void) centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI { if([advertisementData objectForKey:@&quot;kCBAdvDataLocalName&quot;]!=nil){ NSLog(@&quot;I see an advertisement with identifer: %@, state: %ld, name: %@, services: %@, description: %@&quot;, [peripheral identifier], [peripheral state], [peripheral name], [peripheral services], [advertisementData description]); } if (_peripheral == nil) { NSLog(@&quot;Trying to connect to peripheral&quot;); _peripheral = peripheral; _peripheral.delegate = (id)self; [central connectPeripheral:_peripheral options:nil]; } } - (void) centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { if (peripheral == nil) { NSLog(@&quot;connect callback has nil peripheral&quot;); } else { NSLog(@&quot;Connected to peripheral with identifer: %@, state: %ld, name: %@, services: %@&quot;, [peripheral identifier], [peripheral state], [peripheral name], [peripheral services]); NSLog(@&quot;discovering services...&quot;); _peripheral = peripheral; _peripheral.delegate = (id)self; [_peripheral discoverServices:nil]; } } - (void) peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSArray *)serviceUuids { NSLog(@&quot;discovered a peripheral&apos;s services: %@&quot;, serviceUuids); }其中可以過濾掉一些不會廣播的設備 if([advertisementDataobjectForKey:@&quot;kCBAdvDataLocalName&quot;]!=nil){可以取該設備的UUID &lt;__NSConcreteUUID 0x17403f520&gt; 2750A093-A1C2-9953-A59F-A0769538DC15附帶一提的是，小米手環也會廣播自已的藍芽訊號 2. 接著利用 CLLocationManagerDelegate 對 已取得的UUID 對 iBeacon 做程式的實作 for (NSUUID *uuid in [APLDefaults sharedDefaults].supportedProximityUUIDs) { CLBeaconRegion *region = [[CLBeaconRegion alloc] initWithProximityUUID:uuid identifier:[uuid UUIDString]]; self.rangedRegions[region] = [NSArray array]; } #pragma mark - Location manager delegate - (void)locationManager:(CLLocationManager *)manager didRangeBeacons:(NSArray *)beacons inRegion:(CLBeaconRegion *)region { // 這裡就可以取到 iBeacon 了 }在這裡 小米手環 不會出現在 CLLocationManagerDelegate，所以會出現的就只剩下iBeacon了 打完收工","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"[xcode6]打包自已做的framework","slug":"xcode6-打包自已做的framework","date":"2015-04-21T12:56:17.000Z","updated":"2015-07-24T09:08:53.000Z","comments":true,"path":"2015/04/21/xcode6-打包自已做的framework/","link":"","permalink":"http://ios.taipei/2015/04/21/xcode6-打包自已做的framework/","excerpt":"","text":"如何把自已做的code打包成一包framework，給其他人使用 1. 新增一個專案，選取 [Framework &amp; Library] [Cocoa Touch Framework] 2. 在專案中，把要放的程式加到專案中 3. 在[Target][Build Phase][Headers]中設定，要給人看的表頭檔(.h)，和不給人看的表頭檔 4. 新增一個 [Aggregate Target] 5. 在新的 [Aggregate Target][Build Phases]加入 [Run Script]FMK_NAME=${PROJECT_NAME} INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework WRK_DIR=build DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework # -configuration ${CONFIGURATION} # Clean and Building both architectures. xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean build xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build # Cleaning the oldest. if [ -d &quot;${INSTALL_DIR}&quot; ] then rm -rf &quot;${INSTALL_DIR}&quot; fi mkdir -p &quot;${INSTALL_DIR}&quot; cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot; # Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product. lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot; rm -r &quot;${WRK_DIR}&quot; open &quot;${INSTALL_DIR}&quot;如圖 6.最後 builde project，會在[Products] 生成你的個人的framework ps. 如果要生成靜態的library使用，要注意一個設定在 [Build Settings][Mach-O Type] 要選 [Static Library] 7. 最後給別人引用時 要注意一下，除了在[Linked Frameworks and Libraries]下引用之外，還要在[Targer][General][Embeded Binies]下加入自定義的framework 打完收工","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"加入 Admob 廣告","slug":"加入-Admob-廣告","date":"2015-04-14T14:57:56.000Z","updated":"2015-07-25T14:05:04.000Z","comments":true,"path":"2015/04/14/加入-Admob-廣告/","link":"","permalink":"http://ios.taipei/2015/04/14/加入-Admob-廣告/","excerpt":"","text":"AdMob網頁設定1。註冊AdMob 帳號不解釋 2。加入新的應用程式點擊 手動新增應用程式 將廣告單編號複製起來 手機程式1。pod install在專案目錄下新增一個 Podfile 檔 source &apos;https://github.com/CocoaPods/Specs.git&apos; platform :ios, &apos;7.0&apos; pod &apos;Google-Mobile-Ads-SDK&apos;, &apos;~&gt; 7.0&apos;2。在terminal下指令進行安裝pod install安裝好之後，打開新產生的專案的workspace 3。在xib檔建一個UIView,並且將其class改為GADBannerView 接著拉好相對應的 IBOutlet 記得import GoogleMobileAds （語法和一般的import不太一樣） 4。在 ViewDidLoad (or anywhere) 加入對應的程式碼bannerView.adUnitID = @&quot;和網頁的那串相同&quot;; bannerView.rootViewController = self; [bannerView loadRequest:[GADRequest request]];5。看到測試用的ad出現 AdMob網頁設定啟動據aircon解釋，在上架一週後可以搜尋得到應用程式，接著進行連結，就可以啟動admob了 打完收工","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"其他","slug":"其他","permalink":"http://ios.taipei/tags/其他/"}]},{"title":"GameKit tutorial","slug":"GameKit-tutorial","date":"2015-04-12T08:53:19.000Z","updated":"2015-07-24T09:18:38.000Z","comments":true,"path":"2015/04/12/GameKit-tutorial/","link":"","permalink":"http://ios.taipei/2015/04/12/GameKit-tutorial/","excerpt":"","text":"開始使用GAME CENTER###1。在project裡加入 GameKit.framework ###2。在iOS Dev Center 加入對應的AppID，並且在iTunes Connect新增一個APP ###3。[My App][xxxApp][Game Center]下，設定啟用game center ###4。新增一個「個別排行榜」 ###5。enable Game Center ###6。加上 GameKitHelper 的程式碼 ####GameKitHelper.h #import &lt;Foundation/Foundation.h&gt; #import &lt;GameKit/GameKit.h&gt; @protocol GameKitHelperProtocol &lt;NSObject&gt; -(void) onScoresSubmitted:(bool)success; @end @interface GameKitHelper : NSObject&lt;GKGameCenterControllerDelegate&gt; { } @property (nonatomic, assign) id&lt;GameKitHelperProtocol&gt; delegate; // This property holds the last know error // that occured while using the Game Center API&apos;s @property (nonatomic, readonly) NSError* lastError; @property (nonatomic, assign) BOOL gameCenterFeaturesEnabled; +(id) sharedGameKitHelper; // Player authentication, info -(void) authenticateLocalPlayer; // Scores -(void) submitScore:(int64_t)socre; // Show Leaderboard -(void) showLeaderboard; @end####GameKitHelper.m #import &quot;GameKitHelper.h&quot; #import &quot;GameKitHelper.h&quot; @interface GameKitHelper() &lt;GKGameCenterControllerDelegate, UIAlertViewDelegate&gt; { } @end @implementation GameKitHelper @synthesize gameCenterFeaturesEnabled; #pragma mark Singleton stuff +(id) sharedGameKitHelper { static GameKitHelper *sharedGameKitHelper; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedGameKitHelper = [[GameKitHelper alloc] init]; }); return sharedGameKitHelper; } #pragma mark Player Authentication -(void) authenticateLocalPlayer { __weak __block GKLocalPlayer* localPlayer = [GKLocalPlayer localPlayer]; localPlayer.authenticateHandler = ^(UIViewController *viewController, NSError *error) { [self setLastError:error]; // Player already authenticated if ( localPlayer.authenticated) { gameCenterFeaturesEnabled = YES; } else if (viewController) { [self presentViewController:viewController]; } else { gameCenterFeaturesEnabled = NO; } }; } #pragma mark Property setters -(void) setLastError:(NSError *)error { _lastError = [error copy]; if (_lastError) { NSLog(@&quot;GameKitHelper ERROR: [%@] [%@]&quot;, [[_lastError userInfo] description], [_lastError localizedDescription]); /* UIAlertView* alert = [[UIAlertView alloc] initWithTitle:@&quot;Game Center Error&quot; message:[_lastError localizedDescription] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil]; [alert show]; [alert release]; */ } } #pragma mark UIViewController stuff -(UIViewController*) getRootViewController { return [UIApplication sharedApplication].keyWindow.rootViewController; } -(void) presentViewController:(UIViewController*)vc { UIViewController* rootVC = [self getRootViewController]; [rootVC presentViewController:vc animated:YES completion:nil]; } -(void) submitScore:(int64_t)score{ // 1: Check if Game Center // features are enabled if (!gameCenterFeaturesEnabled) { NSLog(@&quot;Player not authenticated&quot;); return; } // 2: Create a GKScore object GKScore* gkScore = [[GKScore alloc]initWithLeaderboardIdentifier:@&quot;yuaki_No5&quot;]; // 3: Set the score value gkScore.value = score; [GKScore reportScores:@[gkScore] withCompletionHandler:^(NSError *error) { if (error) { [self setLastError:error]; BOOL success = (error == nil); if ([_delegate respondsToSelector:@selector(onScoresSubmitted:)]) { [_delegate onScoresSubmitted:success]; } } }]; } -(void) showLeaderboard{ if (!gameCenterFeaturesEnabled) { NSLog(@&quot;Player not authenticated&quot;); return; } GKGameCenterViewController* gameCenterViewController = [[GKGameCenterViewController alloc] init]; gameCenterViewController.viewState = GKGameCenterViewControllerStateLeaderboards; gameCenterViewController.gameCenterDelegate = self; [[self getRootViewController] presentViewController:gameCenterViewController animated:YES completion:nil]; } -(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)gameCenterViewController { [[self getRootViewController] dismissViewControllerAnimated:YES completion:nil]; } @end###7。確認Bundle identifier是否一致 ###8。確認Capabilities － GameCenter 是否無錯誤 ###9。確認info.plist 有無gamekit的Capabilities ###10。在程式的啟動點加入 authenticateLocalPlayer [[GameKitHelper sharedGameKitHelper] authenticateLocalPlayer];###11。Submit Score [[GameKitHelper sharedGameKitHelper] submitScore:[lblScore.text integerValue]];###12。Show LeaderBoard [[GameKitHelper sharedGameKitHelper] showLeaderboard];###13。在手機上測試 這裡有個小地方要注意一下 iOS8必需要在手機上開啟sandox mode，才能進行開發測試 [設定] [Game Center] [Sandbox] 設為開啟 ####xcode 執行 debug 啟動進入程式後會出現 Game Center Sandbox，依序完成 輸入 AppID 確認 Terms and Conditions Create NickNamePrivacy 回到遊戲後即可看到 Game Center的歡迎訊息 #打完收功","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"objc-AirMonitor","slug":"objc-AirMonitor","date":"2015-04-08T12:17:30.000Z","updated":"2015-07-25T13:46:40.000Z","comments":true,"path":"2015/04/08/objc-AirMonitor/","link":"","permalink":"http://ios.taipei/2015/04/08/objc-AirMonitor/","excerpt":"","text":"原始資料來源：http://taqm.epa.gov.tw/pm25/tw/PM25A.aspx?area=10 ##載點 ##說明 為台灣空氣污染監測設計的app 主要監測細懸浮微粒(pm2.5)的單位濃度許多研究已證實細懸浮微粒(pm2.5)會對呼吸系統和心血管系統造成傷害導致哮喘 肺癌 心血管疾病 出生缺陷和過早死亡 功能－即時pm2.5資訊查詢－列表顯示－在今天的畫面可定義監控的顯示區域","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"Symbol - English","slug":"Symbol-English","date":"2015-04-08T09:50:30.000Z","updated":"2015-07-25T13:43:13.000Z","comments":true,"path":"2015/04/08/Symbol-English/","link":"","permalink":"http://ios.taipei/2015/04/08/Symbol-English/","excerpt":"","text":"&amp; Ampersand (And 符號) * Asterisk (星號) @ At sign, at (At 符號，At) \\ Backslash (反斜線) [ Open bracket (左中括弧) ^ Caret (插入號) ] Close bracket (右中括弧) ( Open parenthesis (左括弧) ) Close parenthesis (右括弧) : Colon (冒號) , Comma (逗號) $ Dollar sign (錢符號) – Double dash (雙破折號) … Ellipsis (省略符號) ‘ Single quote (單引號) “ Quote (雙引號) = Equals (等號) + Plus, plus sign (加，加號) ! Exclamation point (驚歎號) &gt; Greater than (大於) &lt; Less than (小於) # Pound sign (井字號) ? Question mark (問號) . Period, dot (句號，點) ; Semicolon (分號) - Hyphen (連字號) — Dash (破折號) _ Underscore (底線) | Vertical bar (垂直線) { Open brace (左大括弧) } Close brace (右大括弧) % Percent, percent sign (百分比，百分比符號) / Slash (斜線) // Double slash (雙斜線) ~ Tilde (取代符號，毛毛蟲)","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://ios.taipei/tags/其他/"}]},{"title":"Clean Code - Boy Scout Rule","slug":"Clean-Code-Boy-Scout-Rule","date":"2015-04-08T09:49:27.000Z","updated":"2015-07-25T13:58:30.000Z","comments":true,"path":"2015/04/08/Clean-Code-Boy-Scout-Rule/","link":"","permalink":"http://ios.taipei/2015/04/08/Clean-Code-Boy-Scout-Rule/","excerpt":"","text":"##Leave the campground cleaner than you found it. ###整理好code再離開，不管是誰留下來的","categories":[],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://ios.taipei/tags/Clean-Code/"}]},{"title":"Clean Code - Naming","slug":"Clean-Code-Naming","date":"2015-04-08T09:48:55.000Z","updated":"2015-07-25T13:57:49.000Z","comments":true,"path":"2015/04/08/Clean-Code-Naming/","link":"","permalink":"http://ios.taipei/2015/04/08/Clean-Code-Naming/","excerpt":"","text":"Use Intention-Revealing Names Avoid Disinformation Make Meaningful Distinctions Use Pronounceable Names Use Searchable Names Avoid Encodings Avoid Mental Mapping Class Names - should have noun or noun phase names Method Names - should have verb or verb phase names Don’t be cute Pick one word per concept Don’t pun - don’t use the same word for two purposes Use solution domain names Use problem domain names Add meaningful context Don’t add gratuitous context","categories":[],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://ios.taipei/tags/Clean-Code/"}]},{"title":"Clean Code - function","slug":"Clean-Code-function","date":"2015-04-08T09:48:23.000Z","updated":"2015-07-25T13:58:15.000Z","comments":true,"path":"2015/04/08/Clean-Code-function/","link":"","permalink":"http://ios.taipei/2015/04/08/Clean-Code-function/","excerpt":"","text":"Small Blocks and Indenting Do one thing One level of abstraction per function Reading code from top to bottom: the Step Down Rule Switch statements Use descriptive names Function arguments - the less the better Common monadic forms *,Dyadic functions, Triads, Argument objects, Agrument Lists, Flag arguments - passing a boolean into a function is a terrible practice Verbs and keywords Have no side effects - do not lie in function Command Query Separation - don’t return different meaning in one function Prefer exceptions to return error codes Extract try/catch blocks Error handling is one thing Dependency magnet. don’t enum the errors Don’t repeat yourself Structured programming","categories":[],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://ios.taipei/tags/Clean-Code/"}]},{"title":"Clean Code - Error Handling","slug":"Clean-Code-Error-Handling","date":"2015-04-08T09:47:45.000Z","updated":"2015-07-25T13:58:21.000Z","comments":true,"path":"2015/04/08/Clean-Code-Error-Handling/","link":"","permalink":"http://ios.taipei/2015/04/08/Clean-Code-Error-Handling/","excerpt":"","text":"Use Exceptions rather than Return Codes Write Your Try-Catch-Finally Statement First Use un-checked exceptions ＊ Provide context with eceptions Define exception classes in terms of a caller’s needs Define the normal flow Don’t return null Don’t pass null","categories":[],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://ios.taipei/tags/Clean-Code/"}]},{"title":"Clean Code - TDDs 3 laws","slug":"Clean-Code-TDDs-3-laws","date":"2015-04-08T09:46:55.000Z","updated":"2015-07-25T13:57:26.000Z","comments":true,"path":"2015/04/08/Clean-Code-TDDs-3-laws/","link":"","permalink":"http://ios.taipei/2015/04/08/Clean-Code-TDDs-3-laws/","excerpt":"","text":"First Law - You may not write production code until you have written a failing unit test. Second Law - You may not write more of a unit test than is sufficient to fail, and not compiling is failing. Third Law - You may not write more production code than is sufficient to pass the currently failing test.","categories":[],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://ios.taipei/tags/Clean-Code/"}]},{"title":"Clean Code - System","slug":"Clean-Code-System","date":"2015-04-08T09:45:45.000Z","updated":"2015-07-25T13:57:36.000Z","comments":true,"path":"2015/04/08/Clean-Code-System/","link":"","permalink":"http://ios.taipei/2015/04/08/Clean-Code-System/","excerpt":"","text":"Separate Constructing a System from Using It Separation of Main Factories Dependency Injection Scaling Up Cross-Cutting Concerns","categories":[],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://ios.taipei/tags/Clean-Code/"}]},{"title":"Android-leap-code-01","slug":"Android-leap-code-01","date":"2015-04-08T09:40:26.000Z","updated":"2015-07-25T14:02:56.000Z","comments":true,"path":"2015/04/08/Android-leap-code-01/","link":"","permalink":"http://ios.taipei/2015/04/08/Android-leap-code-01/","excerpt":"","text":"##河內塔 public static void Move(int disks, int from, int to) { if(disks == 1) { System.out.println(“Move from “ + from + “ to “ + to); return; } int relay = 6 - from - to; Move(disks - 1, from, relay); Move(1, from, to); Move(disks - 1, relay, to); }##Fibonacci public class DivideAndConquer { public static long Fibonacci(int n) { if (n == 0) return 0; if (n == 1) return 1; return Fibonacci(n - 1) + Fibonacci(n - 2); } }##Merge sort###TopDown public class TopDown { public static void Sort(int[] array) { int[] workArray = new int[array.length]; Sort(array, workArray, 0, array.length); } private static void Sort(int[] array, int[] workArray, int start, int count) { if (count &lt; 2) return; Sort(array, workArray, start, count / 2); Sort(array, workArray, start + count / 2, count - count / 2); Merge(array, workArray, start, count / 2, start + count / 2, count - count / 2); } private static void Merge(int[] array, int[] workArray, int leftStart, int leftCount, int rightStart, int rightCount) { int i = leftStart, j = rightStart, leftBound = leftStart + leftCount, rightBound = rightStart + rightCount, index = leftStart; while (i &lt; leftBound || j &lt; rightBound) { if (i &lt; leftBound &amp;&amp; j &lt; rightBound) { if (array[j] &lt; array[i]) workArray[index] = array[j++]; else workArray[index] = array[i++]; } else if (i &lt; leftBound) workArray[index] = array[i++]; else workArray[index] = array[j++]; ++index; } for (i = leftStart; i &lt; index; ++i) array[i] = workArray[i]; } }##BottomUp public class BottomUp { public static void Sort(int[] array) { int[] workArray = new int[array.length]; for (int count = 1; count &lt; array.length; count *= 2) for (int leftStart = 0; leftStart &lt; array.length; leftStart += 2 * count) { if (count &gt; array.length - leftStart) break; Merge(array, workArray, leftStart, count, leftStart + count, Math.min(count, array.length - leftStart - count)); } } private static void Merge(int[] array, int[] workArray, int leftStart, int leftCount, int rightStart, int rightCount) { int i = leftStart, j = rightStart, leftBound = leftStart + leftCount, rightBound = rightStart + rightCount, index = leftStart; while (i &lt; leftBound || j &lt; rightBound) { if (i &lt; leftBound &amp;&amp; j &lt; rightBound) { if (array[j] &lt; array[i]) workArray[index] = array[j++]; else workArray[index] = array[i++]; } else if (i &lt; leftBound) workArray[index] = array[i++]; else workArray[index] = array[j++]; ++index; } for (i = leftStart; i &lt; index; ++i) array[i] = workArray[i]; } }##Quick Sort import java.util.List; import java.util.Random; import java.util.ArrayList; public class ObjectOriented { static Random random = new Random(); public static void Sort(int[] array) { List list = new ArrayList(); for (int n : array) list.add(n); list = Sort(list); for (int i = 0;i &lt; array.length;++i) array[i] = list.get(i); } public static List Sort(List list) { if (list.size() &lt; 2) return list; // random pivot //int pivot = list.get(random.nextInt(list.size() - 1)); // middle pivot int pivot = list.get(list.size() / 2); list.remove(list.size() / 2); List less = new ArrayList(); List greater = new ArrayList(); List result = new ArrayList(); for (Integer n : list) { if (n &gt; pivot) greater.add(n); else less.add(n); } result.addAll(Sort(less)); result.add(pivot); result.addAll(Sort(greater)); return result; } }##Binary Search public class DivideAndConquer { static public int Search(int[] array, int num) { return Search(array, num, 0, array.length - 1); } static public int Search(int[] array, int num, int left, int right) { if (left &gt; right) return -1; int middle = (right + left) / 2; if (array[middle] == num) return middle; if (array[middle] &gt; num) return Search(array, num, left, middle - 1); return Search(array, num, middle + 1, right); } }##下樓梯 public class Iterative { public static long DownStairs(int n) { long v1 = 1; long v2 = 2; long result = n; for (int i = 2; i &lt;= n; ++i) { result = v2 + v1; v1 = v2; v2 = result; } return result; } } ##總和遞迴 int sum(int n) { if(n &lt; 1) return 0; return n + sum(n - 1); }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ios.taipei/tags/Android/"}]},{"title":"Android-Thread-Save Singleton","slug":"Android-Thread-Save-Singleton","date":"2015-04-08T09:38:45.000Z","updated":"2015-07-25T13:58:40.000Z","comments":true,"path":"2015/04/08/Android-Thread-Save-Singleton/","link":"","permalink":"http://ios.taipei/2015/04/08/Android-Thread-Save-Singleton/","excerpt":"","text":"Android Thread-Save Singletonpublic class ThreadSafeSingleton { private static final Object instance = new Object(); protected ThreadSafeSingleton() { } // Runtime initialization // By defualt ThreadSafe public static Object getInstance() { return instance; } }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ios.taipei/tags/Android/"}]},{"title":"Android-shrinkTextView","slug":"Android-shrinkTextView","date":"2015-04-08T09:37:27.000Z","updated":"2015-07-25T14:00:45.000Z","comments":true,"path":"2015/04/08/Android-shrinkTextView/","link":"","permalink":"http://ios.taipei/2015/04/08/Android-shrinkTextView/","excerpt":"","text":"自動縮小字型的TextViewprivate void shrinkText(final TextView wv, final String word) { wv.setTextSize(defaultTextSize); new Thread(new Runnable() { @Override public void run() { while (wv.getWidth()&gt;0 &amp;&amp; wv.getPaint().measureText(word) &gt; wv.getWidth()) { Logg.d(&quot;word too big. Shrink from &quot; + wv.getTextSize()/density + &quot; to &quot; + (wv.getTextSize()/density-1.0f)); wv.post(new Runnable() { public void run() { wv.setTextSize(wv.getTextSize() / density - 1.0f); } }); } }).start(); }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ios.taipei/tags/Android/"}]},{"title":"objc-因為版本不同出現no interface的解法","slug":"objc-因為版本不同出現no-interface的解法","date":"2015-04-08T09:29:06.000Z","updated":"2015-07-25T13:48:57.000Z","comments":true,"path":"2015/04/08/objc-因為版本不同出現no-interface的解法/","link":"","permalink":"http://ios.taipei/2015/04/08/objc-因為版本不同出現no-interface的解法/","excerpt":"","text":"##Send Action if ([self.locationManager respondsToSelector:@selector(requestWhenInUseAuthorization)]) { [[UIApplication sharedApplication] sendAction:@selector(requestWhenInUseAuthorization) to:self.locationManager from:self forEvent:nil]; }","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"objc-增加UIButton的點擊範圍 - objc_setAssociatedObject 的應用","slug":"objc-增加UIButton的點擊範圍-objc-setAssociatedObject-的應用","date":"2015-04-08T09:26:53.000Z","updated":"2015-07-25T13:47:21.000Z","comments":true,"path":"2015/04/08/objc-增加UIButton的點擊範圍-objc-setAssociatedObject-的應用/","link":"","permalink":"http://ios.taipei/2015/04/08/objc-增加UIButton的點擊範圍-objc-setAssociatedObject-的應用/","excerpt":"","text":"UIButton的進階使用一般人比較少接觸到的runtime programming 以下為其中之一objc_setAssociatedObject 的應用 @interface UIButton(EnlargeTouchArea) @end @implementation UIButton(EnlargeTouchArea) static char topNameKey; static char rightNameKey; static char bottomNameKey; static char leftNameKey; - (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left { objc_setAssociatedObject(self, &amp;topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC); objc_setAssociatedObject(self, &amp;rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC); objc_setAssociatedObject(self, &amp;bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC); objc_setAssociatedObject(self, &amp;leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC); } - (CGRect) enlargedRect { NSNumber* topEdge = objc_getAssociatedObject(self, &amp;topNameKey); NSNumber* rightEdge = objc_getAssociatedObject(self, &amp;rightNameKey); NSNumber* bottomEdge = objc_getAssociatedObject(self, &amp;bottomNameKey); NSNumber* leftEdge = objc_getAssociatedObject(self, &amp;leftNameKey); if (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge) { return CGRectMake(self.bounds.origin.x - leftEdge.floatValue, self.bounds.origin.y - topEdge.floatValue, self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue, self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue); } else { return self.bounds; } } - (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event { CGRect rect = [self enlargedRect]; if (CGRectEqualToRect(rect, self.bounds)) { return [super hitTest:point withEvent:event]; } return CGRectContainsPoint(rect, point) ? self : nil; } @end","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"objc-Thread-Save Singleton","slug":"objc-Thread-Save-Singleton","date":"2015-04-08T09:24:27.000Z","updated":"2015-07-25T13:46:30.000Z","comments":true,"path":"2015/04/08/objc-Thread-Save-Singleton/","link":"","permalink":"http://ios.taipei/2015/04/08/objc-Thread-Save-Singleton/","excerpt":"","text":"Thread-Save Singleton@implementation SingletonClass + (id)sharedInstance { static SingletonClass *sharedMyInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedMyInstance = [[super allocWithZone:nil] init]; }); return sharedMyInstance; } @end + (id)allocWithZone:(NSZone *)zone { return [self sharedInstance]; }","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"How to Hexo","slug":"How-to-Hexo","date":"2015-04-07T08:12:37.000Z","updated":"2015-07-24T09:22:59.000Z","comments":true,"path":"2015/04/07/How-to-Hexo/","link":"","permalink":"http://ios.taipei/2015/04/07/How-to-Hexo/","excerpt":"","text":"##1.本機環境設定 首先你要有node.js，這是一套快速、簡單且功能強大的 Node.js 網誌框架。 接著你要用 npm install -g hexo 來安裝 理論上這樣就完成了，發現前面加上 sudo 就可以解決資料夾控制權的問題。 ##2.github帳號設定 有自已的github帳號 在主頁右上方創建一個新的 [repo] [create new repo] Repository name 填入 github帳號.github.io 用來創建github page ##3.開始使用hexo 第一次建立hexo時要先將hexo初始化（建議建立一個hexo資料夾存放資料） hexo init如果有提示要輸入 npm install的話 也要 npm install接著 需要安裝 deployer npm install hexo-deployer-git --save建立一篇文章，將會是Markdown形式，可以到source/_post/title.md去修改 hexo new &quot;title&quot;編輯md檔，增添你要的文章與tag，建議使用 MOU 編輯，可以很快地看到自已編寫的內容格式是否正確 接著，生成public檔案 hexo generate可以在本機事先預覽（chrome需要用localhost來取代0.0.0.0） hexo server##4.上傳至github 修改 hexo的資料夾裡的 _config.yml 檔案 比對一下，原始檔，填入自已的資料 # Site title: 沒有人的地盤 subtitle: mobile app development description: author: AKI YU －－－－－－中間省略－－－－－－－－－－－－ deploy: type: git repository: git@github.com:github帳號/github帳號.github.io.git branch: master編輯存檔後發佈 hexo deploy成功的話可以用瀏覽器看一下 http://github帳號.github.io打完收功","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://ios.taipei/tags/其他/"}]},{"title":"swift-xmlParser之使用","slug":"swift-xmlParser之使用","date":"2015-04-07T06:21:41.000Z","updated":"2015-07-25T13:43:17.000Z","comments":true,"path":"2015/04/07/swift-xmlParser之使用/","link":"","permalink":"http://ios.taipei/2015/04/07/swift-xmlParser之使用/","excerpt":"","text":"在ViewController後引用所需要的 delegate class ViewController: ViewController,NSXMLParserDelegate 加入delegate所需要的function func parser(parser: NSXMLParser!, didStartElement elementName: String!, namespaceURI: String!, qualifiedName qName: String!, attributes attributeDict: [NSObject : AnyObject]!) { println(&quot;Element&apos;s name is \\(elementName)&quot;) println(&quot;Element&apos;s attributes are \\(attributeDict)&quot;) } func parser(parser: NSXMLParser!, foundCharacters string: String!) { } func parser(parser: NSXMLParser!, didEndElement elementName: String!, namespaceURI: String!, qualifiedName qName: String!) { println(&quot;End&quot;) } 在接收到資料後，轉為nsdata，並使用parser去執行（以下為範例） let xml = (&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;&lt;rsp stat=\\&quot;fail\\&quot;&gt;&lt;err code=\\&quot;123\\&quot; msg=\\&quot;Failed\\&quot; desc=\\&quot;錯誤\\&quot;/&gt;&lt;/rsp&gt;&quot;).dataUsingEncoding(NSUTF8StringEncoding) var xmlParser: NSXMLParser = NSXMLParser(data: xml) xmlParser.delegate = self xmlParser.parse() 跑跑看結果是否正確 Element&apos;s name is rsp Element&apos;s attributes are [stat: fail] Element&apos;s name is err Element&apos;s attributes are [msg: Failed, desc: 錯誤, code: 123] End End 收工","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"objc-WaterMonitor","slug":"objc-WaterMonitor","date":"2015-04-07T02:32:05.000Z","updated":"2015-07-25T13:43:29.000Z","comments":true,"path":"2015/04/07/objc-WaterMonitor/","link":"","permalink":"http://ios.taipei/2015/04/07/objc-WaterMonitor/","excerpt":"","text":"原始資料來源：http://fhy.wra.gov.tw/ReservoirPage_2011/StorageCapacity.aspx ##原始碼 ##載點 ##說明 有許多資訊人對於週遭環境的關心，但是少了objc的版本，於此補上一份 內容有 1） html parser 2） 動畫 3） today extension 4） vpon 5） 其他小技巧 html parser - TFHpplewater effect - VWWater https://github.com/jarvislin/Water-Restriction-Info 向上面這個專案致敬.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"}]},{"title":"PlaceHolder of UITextview","slug":"UIPlaceHolderTextView.","date":"2014-07-02T15:00:00.000Z","updated":"2019-10-12T06:42:18.616Z","comments":true,"path":"2014/07/02/UIPlaceHolderTextView./","link":"","permalink":"http://ios.taipei/2014/07/02/UIPlaceHolderTextView./","excerpt":"Q: UITextView 沒有 placeholder， 那就自己做一個吧","text":"Q: UITextView 沒有 placeholder， 那就自己做一個吧 UIPlaceHolderTextView.h:#import &lt;Foundation/Foundation.h&gt; IB_DESIGNABLE @interface UIPlaceHolderTextView : UITextView @property (nonatomic, retain) IBInspectable NSString *placeholder; @property (nonatomic, retain) IBInspectable UIColor *placeholderColor; -(void)textChanged:(NSNotification*)notification; @endUIPlaceHolderTextView.m:#import &quot;UIPlaceHolderTextView.h&quot; @interface UIPlaceHolderTextView () @property (nonatomic, retain) UILabel *placeHolderLabel; @end @implementation UIPlaceHolderTextView CGFloat const UI_PLACEHOLDER_TEXT_CHANGED_ANIMATION_DURATION = 0.25; - (void)dealloc { [[NSNotificationCenter defaultCenter] removeObserver:self]; #if __has_feature(objc_arc) #else [_placeHolderLabel release]; _placeHolderLabel = nil; [_placeholderColor release]; _placeholderColor = nil; [_placeholder release]; _placeholder = nil; [super dealloc]; #endif } - (void)awakeFromNib { [super awakeFromNib]; // Use Interface Builder User Defined Runtime Attributes to set // placeholder and placeholderColor in Interface Builder. if (!self.placeholder) { [self setPlaceholder:@&quot;&quot;]; } if (!self.placeholderColor) { [self setPlaceholderColor:[UIColor lightGrayColor]]; } [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChanged:) name:UITextViewTextDidChangeNotification object:nil]; } - (id)initWithFrame:(CGRect)frame { if( (self = [super initWithFrame:frame]) ) { [self setPlaceholder:@&quot;&quot;]; [self setPlaceholderColor:[UIColor lightGrayColor]]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChanged:) name:UITextViewTextDidChangeNotification object:nil]; } return self; } - (void)textChanged:(NSNotification *)notification { if([[self placeholder] length] == 0) { return; } [UIView animateWithDuration:UI_PLACEHOLDER_TEXT_CHANGED_ANIMATION_DURATION animations:^{ if([[self text] length] == 0) { [[self viewWithTag:999] setAlpha:1]; } else { [[self viewWithTag:999] setAlpha:0]; } }]; } - (void)setText:(NSString *)text { [super setText:text]; [self textChanged:nil]; } - (void)drawRect:(CGRect)rect { if( [[self placeholder] length] &gt; 0 ) { if (_placeHolderLabel == nil ) { _placeHolderLabel = [[UILabel alloc] initWithFrame:CGRectMake(8,8,self.bounds.size.width - 16,0)]; _placeHolderLabel.lineBreakMode = NSLineBreakByWordWrapping; _placeHolderLabel.numberOfLines = 0; _placeHolderLabel.font = self.font; _placeHolderLabel.backgroundColor = [UIColor clearColor]; _placeHolderLabel.textColor = self.placeholderColor; _placeHolderLabel.alpha = 0; _placeHolderLabel.tag = 999; [self addSubview:_placeHolderLabel]; } _placeHolderLabel.text = self.placeholder; [_placeHolderLabel sizeToFit]; [self sendSubviewToBack:_placeHolderLabel]; } if( [[self text] length] == 0 &amp;&amp; [[self placeholder] length] &gt; 0 ) { [[self viewWithTag:999] setAlpha:1]; } [super drawRect:rect]; } @endswiftimport UIKit class PlaceholderTextView: UITextView { @IBInspectable var placeholderColor: UIColor = UIColor.lightGray @IBInspectable var placeholderText: String = &quot;&quot; override var font: UIFont? { didSet { setNeedsDisplay() } } override var contentInset: UIEdgeInsets { didSet { setNeedsDisplay() } } override var textAlignment: NSTextAlignment { didSet { setNeedsDisplay() } } override var text: String? { didSet { setNeedsDisplay() } } override var attributedText: NSAttributedString? { didSet { setNeedsDisplay() } } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) setUp() } override init(frame: CGRect, textContainer: NSTextContainer?) { super.init(frame: frame, textContainer: textContainer) } private func setUp() { NotificationCenter.default.addObserver(self, selector: #selector(self.textChanged(notification:)), name: Notification.Name(&quot;UITextViewTextDidChangeNotification&quot;), object: nil) } @objc func textChanged(notification: NSNotification) { setNeedsDisplay() } func placeholderRectForBounds(bounds: CGRect) -&gt; CGRect { var x = contentInset.left + 4.0 var y = contentInset.top + 9.0 let w = frame.size.width - contentInset.left - contentInset.right - 16.0 let h = frame.size.height - contentInset.top - contentInset.bottom - 16.0 if let style = self.typingAttributes[NSAttributedString.Key.paragraphStyle] as? NSParagraphStyle { x += style.headIndent y += style.firstLineHeadIndent } return CGRect(x: x, y: y, width: w, height: h) } override func draw(_ rect: CGRect) { if text!.isEmpty &amp;&amp; !placeholderText.isEmpty { let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.alignment = textAlignment let attributes: [NSAttributedString.Key: Any] = [ NSAttributedString.Key(rawValue: NSAttributedString.Key.font.rawValue) : font!, NSAttributedString.Key(rawValue: NSAttributedString.Key.foregroundColor.rawValue) : placeholderColor, NSAttributedString.Key(rawValue: NSAttributedString.Key.paragraphStyle.rawValue) : paragraphStyle] placeholderText.draw(in: placeholderRectForBounds(bounds: bounds), withAttributes: attributes) } super.draw(rect) } }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"swift","slug":"swift","permalink":"http://ios.taipei/tags/swift/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"TextView","slug":"TextView","permalink":"http://ios.taipei/tags/TextView/"}]},{"title":"圖片的裁切","slug":"ImageCrop","date":"2013-06-13T15:00:00.000Z","updated":"2019-10-12T06:19:18.257Z","comments":true,"path":"2013/06/13/ImageCrop/","link":"","permalink":"http://ios.taipei/2013/06/13/ImageCrop/","excerpt":"Q: 這邊要教你把某一個UIImage 重新裁切","text":"Q: 這邊要教你把某一個UIImage 重新裁切 實作一個category @implementation UIImage (Crop) - (UIImage *)crop:(CGRect)rect { rect = CGRectMake(rect.origin.x*self.scale, rect.origin.y*self.scale, rect.size.width*self.scale, rect.size.height*self.scale); CGImageRef imageRef = CGImageCreateWithImageInRect([self CGImage], rect); UIImage *result = [UIImage imageWithCGImage:imageRef scale:self.scale orientation:self.imageOrientation]; CGImageRelease(imageRef); return result; } @end使用 UIImage *imageToCrop = &lt;yourImageToCrop&gt;; CGRect cropRect = &lt;areaYouWantToCrop&gt;; UIImage *croppedImage = [imageToCrop crop:cropRect];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"CCLayer","slug":"CCLayer","permalink":"http://ios.taipei/tags/CCLayer/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"crop","slug":"crop","permalink":"http://ios.taipei/tags/crop/"}]},{"title":"在 ViewConrtoller 之間傳遞值","slug":"PassDataBetweenVCs","date":"2011-03-12T15:00:00.000Z","updated":"2019-10-12T05:50:44.243Z","comments":true,"path":"2011/03/12/PassDataBetweenVCs/","link":"","permalink":"http://ios.taipei/2011/03/12/PassDataBetweenVCs/","excerpt":"Q: 在ViewController之間有那些傳遞值的方法呢？","text":"Q: 在ViewController之間有那些傳遞值的方法呢？ VC A 將值塞入下一個 VC B利用 property 當做是變數來存放值在 VC B 寫一個 property BOOL 值 isOpen 為例 @property (nonatomic, assign) BOOL isOpen;由 VC A 將 VC B 建立起來的同時，將值塞入 VC B ViewControllerB *vcB = [[ViewControllerB alloc] initWithNib:@&quot;vcB&quot; bundle:nil]; vcB.isOpen = YES; [[[self navigationController]] pushViewController:vcB animated:YES]; 不使用push 的話 可以放入 Segue -(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{ if([segue.identifier isEqualToString:@&quot;showDetailSegue&quot;]){ ViewControllerB *vcB = (ViewControllerB *)segue.destinationViewController; vcB.isOpen = YES; } }VC A 將 VC B 的值 透過 delegate 取回為 VC B 建立一個protocol 和 delegate Protocol@class ViewControllerB; @protocol ViewControllerBDelegate &lt;NSObject&gt; - (void)didEnteringItem:(NSString *)item; @endDelegate@property (nonatomic, weak) id &lt;ViewControllerBDelegate&gt; delegate;VC A 要使用 VC B 的 deletegate時，必須在自己的interface上將delegate引用進來 @interface ViewControllerA : UIViewController &lt;ViewControllerBDelegate&gt;並且在 .m 裡實作 protocol 需要的函數 - (void)didEnteringItem:(NSString *)item { NSLog(@&quot;Value from VC B %@&quot;,item); }最後 在 VC B 建立的同時，告訴他 delegate是 vc A ViewControllerB *vcB = [[ViewControllerB alloc] initWithNib:@&quot;vcB&quot; bundle:nil]; vcB.delegate = self [[self navigationController] pushViewController:vcB animated:YES];在 vc B 操作的時候，只要呼叫 [self.delegate didEnteringItem:@&quot;test&quot;];vc A 就收到值了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"新手村","slug":"新手村","permalink":"http://ios.taipei/tags/新手村/"},{"name":"OBJC","slug":"OBJC","permalink":"http://ios.taipei/tags/OBJC/"},{"name":"資料","slug":"資料","permalink":"http://ios.taipei/tags/資料/"}]}]}