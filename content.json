{"meta":{"title":"iOS @ Taipei","subtitle":"iOS and her good friends","description":"We are the guys who fall in love with iOS","author":"AKI YU","url":"http://ios.taipei"},"pages":[],"posts":[{"title":"GCD","slug":"GCD","date":"2018-06-21T15:08:55.000Z","updated":"2018-06-21T15:12:08.991Z","comments":true,"path":"2018/06/21/GCD/","link":"","permalink":"http://ios.taipei/2018/06/21/GCD/","excerpt":"GCD 有許多用法，不知道你會那幾種？","text":"GCD 有許多用法，不知道你會那幾種？ 1. 背景執行 12345678let defaultPriority = DISPATCH_QUEUE_PRIORITY_DEFAULTlet backgroundQueue = dispatch_get_global_queue(defaultPriority, 0)dispatch_async(backgroundQueue, &#123; let result = doSomeExpensiveWork() dispatch_async(dispatch_get_main_queue(), &#123; //use `result` somehow &#125;)&#125;) 2. Singleton 12345678+ (instancetype) sharedInstance &#123; static dispatch_once_t onceToken; static id sharedInstance; dispatch_once(&amp;amp;amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 3. with blocks 12345678910111213141516typealias DoneBlock = () -&amp;gt; ()typealias WorkBlock = (DoneBlock) -&amp;gt; ()class AsyncSerialWorker &#123; private let serialQueue = dispatch_queue_create(\"ios.taipei.queue\", DISPATCH_QUEUE_SERIAL) func enqueueWork(work: WorkBlock) &#123; dispatch_async(serialQueue) &#123; let semaphore = dispatch_semaphore_create(0) work(&#123; dispatch_semaphore_signal(semaphore) &#125;) dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) &#125; &#125;&#125; 4. multi-task 123456789dispatch_group_t group = dispatch_group_create() for item in someArray &#123; dispatch_group_async(group, backgroundQueue, &#123; performExpensiveWork(item: item) &#125;) &#125; dispatch_group_notify(group, dispatch_get_main_queue(), &#123; // all the work is complete&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"http://ios.taipei/tags/GCD/"}]},{"title":"XCode 搜尋小技巧","slug":"xcode-search","date":"2018-06-21T15:00:28.000Z","updated":"2018-06-21T15:22:15.410Z","comments":true,"path":"2018/06/21/xcode-search/","link":"","permalink":"http://ios.taipei/2018/06/21/xcode-search/","excerpt":"茫茫碼海中，要怎麼找到你想要找的那一段程式碼？關鍵字下的不夠精準，找不到或是搜尋的資料太多，都是種苦惱。還是想找個Hex? 找Tab? 找ip？ 找url？ 找email? 好的搜尋技巧帶你上天堂，下面幾個技巧該可以能帶你上天堂","text":"茫茫碼海中，要怎麼找到你想要找的那一段程式碼？關鍵字下的不夠精準，找不到或是搜尋的資料太多，都是種苦惱。還是想找個Hex? 找Tab? 找ip？ 找url？ 找email? 好的搜尋技巧帶你上天堂，下面幾個技巧該可以能帶你上天堂 定義搜尋（只搜尋「定義」的字串）搜尋關鍵字會把所有找到的資料帶出來（以simple為例） 在find的第二層，將搜尋改為definition 結果就只會出現「定義」裡的關鍵字搜尋了 &nbsp; 2. Pattern 在搜尋裡先打一個「”」,用以區隔 pattern之用，接著，在放大鏡裡點選 insert pattern 接著，點選「url」,再補個「”」給他 結果，就是我們想要的結果 3. 指定路徑 如果是已知路徑下搜尋，只要在 下方的「in Workspace」點一下 再點選你要搜尋的路徑就可以了 有興趣的人還有scope的進階版可以玩 Call Hierarchy 想知道有誰呼叫了某個函數？ 還有一個方法，就是當你移到函數的位置時","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"xCode","slug":"xCode","permalink":"http://ios.taipei/tags/xCode/"}]},{"title":"SpotLight 初探","slug":"Spotlight-inspect","date":"2018-06-21T15:00:28.000Z","updated":"2018-06-21T15:30:02.014Z","comments":true,"path":"2018/06/21/Spotlight-inspect/","link":"","permalink":"http://ios.taipei/2018/06/21/Spotlight-inspect/","excerpt":"當使用者使用spotlight查詢時，總是有些app會列出內容出來，那又是怎麼樣的小技巧呢？","text":"當使用者使用spotlight查詢時，總是有些app會列出內容出來，那又是怎麼樣的小技巧呢？ 先把兩個必要的framework包進來 import CoreSpotlightimport MobileCoreServices接著，準備一個獨立的ID，避免與別的app衝突，通常會使用域名反解，與一個資料陣列,型別為 CSSearchableItem 12let domainID: String = \"com.yuaki.informationPlus\"var searchableItems: [CSSearchableItem] = [] 接著， 定義每筆資料的屬性設定 (item為資料物件) 12345let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeItem as String)attributeSet.title = item.titleattributeSet.contentDescription = item.subtitleattributeSet.contentCreationDate = item.date 接著為這個屬性設定關鍵字,以方便被搜尋 1234// define search keywordsvar keywords = item.title.componentsSeparatedByString(\" \")keywords.appendContentsOf(item.subtitle.componentsSeparatedByString(\" \"))attributeSet.keywords = keywords 然後把屬性放到 CSSearchableItem裡 再加到陣列中備用 let searchItem = CSSearchableItem(uniqueIdentifier: “Parking”, domainIdentifier: domainID, attributeSet: attributeSet)searchableItems.append(searchItem)最後加到index裡 1234567CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) &#123; (error) -&amp;gt; Void in if error != nil &#123; print(error?.localizedDescription) &#125;else&#123; print(\"items indexed witch success!\") &#125;&#125; 醬子就好了！！！ 其中uniqueIdentifier可以在 continueUserActivity 的userInfo 被撈取 有沒有很方便呀 附記：index看起來沒有容量的限制，意思是…… 我可以塞爆他嗎？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://ios.taipei/tags/iOS/"},{"name":"spotlight","slug":"spotlight","permalink":"http://ios.taipei/tags/spotlight/"}]}]}